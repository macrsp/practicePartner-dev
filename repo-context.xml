This file is a merged representation of a subset of the codebase, containing specifically included files and files not matching ignore patterns, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

- Pay special attention to the Repository Instruction. These contain important context and guidelines specific to this project.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: **/*
- Files matching these patterns are excluded: dist, repo-context.xml
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.github/
  workflows/
    update-repo-context.yml
src/
  app/
    bootstrap.js
    router.js
    state.js
  features/
    activities/
      activities-controller.js
      activities-ui.js
    profiles/
      profiles-controller.js
      profiles-ui.js
    sections/
      sections-controller.js
      sections-ui.js
      selection-controller.js
    tracks/
      music-folder-store.js
      tracks-controller.js
      tracks-ui.js
  persistence/
    activity-store.js
    db.js
  shared/
    constants.js
    shell-ui.js
    utils.js
    waveform.js
.gitignore
index.html
planning-context.md
repomix-instruction.md
repomix.config.json
styles.css
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="src/features/activities/activities-controller.js">
/**
 * @role controller
 * @owns reusable-activity state refresh and CRUD orchestration
 * @not-owns Today list ordering, practice-mode execution, or DOM rendering
 * @notes This controller is scaffolded so later feature work can land without another structural move.
 */

import { state } from "../../app/state.js";
import {
  addActivity,
  deleteActivity,
  getActivitiesByProfile,
  updateActivity,
} from "../../persistence/activity-store.js";
import { ACTIVITY_TARGET_TYPES } from "../../shared/constants.js";

const VALID_TARGET_TYPES = new Set(Object.values(ACTIVITY_TARGET_TYPES));

export function createActivitiesController({ handleError } = {}) {
  async function refreshActivities() {
    if (!state.currentProfileId) {
      state.activities = [];
      return [];
    }

    const activities = await getActivitiesByProfile(state.currentProfileId);
    state.activities = activities;
    return activities;
  }

  async function createActivity(input) {
    try {
      validateActivityInput(input);

      const activityId = await addActivity({
        profileId: state.currentProfileId,
        name: input.name.trim(),
        targetType: input.targetType,
        trackName: input.trackName ?? null,
        sectionId: input.sectionId ?? null,
        customReference: input.customReference?.trim() ?? null,
        createdAt: Date.now(),
        updatedAt: Date.now(),
      });

      await refreshActivities();
      return activityId;
    } catch (error) {
      handleError?.(error);
      return null;
    }
  }

  async function saveActivity(activity) {
    try {
      validateActivityInput(activity);

      await updateActivity({
        ...activity,
        updatedAt: Date.now(),
      });

      await refreshActivities();
    } catch (error) {
      handleError?.(error);
    }
  }

  async function removeActivity(activityId) {
    try {
      await deleteActivity(activityId);
      await refreshActivities();
    } catch (error) {
      handleError?.(error);
    }
  }

  return {
    refreshActivities,
    createActivity,
    saveActivity,
    removeActivity,
  };
}

function validateActivityInput(input) {
  if (!input?.name?.trim()) {
    throw new Error("Activity name is required.");
  }

  if (!VALID_TARGET_TYPES.has(input.targetType)) {
    throw new Error("Activity target type is invalid.");
  }

  if (input.targetType === ACTIVITY_TARGET_TYPES.TRACK && !input.trackName) {
    throw new Error("Track activities require a track.");
  }

  if (input.targetType === ACTIVITY_TARGET_TYPES.SECTION && !input.sectionId) {
    throw new Error("Section activities require a saved section.");
  }

  if (
    input.targetType === ACTIVITY_TARGET_TYPES.CUSTOM &&
    !input.customReference?.trim()
  ) {
    throw new Error("Custom activities require a reference.");
  }
}
</file>

<file path="src/features/activities/activities-ui.js">
/**
 * @role renderer
 * @owns activity-label formatting and future activity-list presentation helpers
 * @not-owns activity persistence, routing, or Today list logic
 * @notes This file is intentionally thin until the activity UI surface is wired.
 */

import { ACTIVITY_TARGET_TYPES } from "../../shared/constants.js";

export function getActivityTargetLabel(targetType) {
  switch (targetType) {
    case ACTIVITY_TARGET_TYPES.TRACK:
      return "Track";
    case ACTIVITY_TARGET_TYPES.SECTION:
      return "Saved section";
    case ACTIVITY_TARGET_TYPES.CUSTOM:
      return "Custom";
    default:
      return "Unknown";
  }
}

export function describeActivity(activity) {
  if (!activity) {
    return "";
  }

  switch (activity.targetType) {
    case ACTIVITY_TARGET_TYPES.TRACK:
      return `${activity.name} • Track: ${activity.trackName ?? "—"}`;
    case ACTIVITY_TARGET_TYPES.SECTION:
      return `${activity.name} • Saved section`;
    case ACTIVITY_TARGET_TYPES.CUSTOM:
      return `${activity.name} • ${activity.customReference ?? "Custom reference"}`;
    default:
      return activity.name ?? "";
  }
}
</file>

<file path="src/features/profiles/profiles-controller.js">
/**
 * @role controller
 * @owns default-profile bootstrap, profile creation, profile refresh, and profile selection state transitions
 * @not-owns section logic, track logic, or direct IndexedDB schema management
 * @notes This controller may trigger section refreshes after profile changes.
 */

import { DEFAULT_PROFILE_NAME } from "../../shared/constants.js";
import { addProfile, getAllProfiles } from "../../persistence/db.js";
import { state } from "../../app/state.js";
import { renderProfiles } from "./profiles-ui.js";

export function createProfilesController({ refreshSections, handleError }) {
  async function ensureDefaultProfile() {
    const profiles = await getAllProfiles();

    if (!profiles.length) {
      await addProfile({ name: DEFAULT_PROFILE_NAME });
    }
  }

  async function refreshProfiles() {
    const profiles = await getAllProfiles();
    state.profiles = profiles;

    if (!profiles.length) {
      state.currentProfileId = null;
      renderProfiles([], null);
      await refreshSections();
      return;
    }

    if (!profiles.some((profile) => profile.id === state.currentProfileId)) {
      state.currentProfileId = profiles[0].id;
    }

    renderProfiles(profiles, state.currentProfileId);
    await refreshSections();
  }

  async function createProfile() {
    try {
      const name = window.prompt("Profile name?");
      const trimmed = name?.trim();

      if (!trimmed) {
        return;
      }

      const profileId = await addProfile({ name: trimmed });
      state.currentProfileId = profileId;
      await refreshProfiles();
    } catch (error) {
      handleError(error);
    }
  }

  function setCurrentProfileId(profileId) {
    state.currentProfileId = profileId;
    state.focusedSectionId = null;
    state.currentPlayingSectionId = null;
  }

  return {
    ensureDefaultProfile,
    refreshProfiles,
    createProfile,
    setCurrentProfileId,
  };
}
</file>

<file path="src/features/profiles/profiles-ui.js">
/**
 * @role renderer
 * @owns profile-select rendering
 * @not-owns profile state transitions, persistence, or validation
 * @notes Keep this file presentation-only.
 */

import { elements } from "../../shared/shell-ui.js";

export function renderProfiles(profiles, currentProfileId) {
  elements.profileSelect.innerHTML = "";

  if (!profiles.length) {
    const option = document.createElement("option");
    option.textContent = "No profiles";
    option.disabled = true;
    option.selected = true;
    elements.profileSelect.appendChild(option);
    elements.profileSelect.disabled = true;
    return;
  }

  profiles.forEach((profile) => {
    const option = document.createElement("option");
    option.value = String(profile.id);
    option.textContent = profile.name;
    elements.profileSelect.appendChild(option);
  });

  elements.profileSelect.disabled = false;
  elements.profileSelect.value = String(currentProfileId);
}
</file>

<file path="src/features/sections/sections-controller.js">
/**
 * @role controller
 * @owns section CRUD, focused-section navigation, adaptive play, section playback boundaries, completion tracking, and track-scoped section browsing
 * @not-owns folder persistence, raw track enumeration, or waveform rendering internals
 * @notes This controller coordinates with track loading when a section references another track.
 */

import {
  addPlayLog,
  addSection,
  deleteSection,
  getSectionsByProfile,
  updateSection,
} from "../../persistence/db.js";
import { state } from "../../app/state.js";
import { elements } from "../../shared/shell-ui.js";
import {
  calculateMastery,
  chooseAdaptiveSection,
  createSectionLabel,
  normalizeSectionRecord,
  sortSections,
} from "../../shared/utils.js";
import { renderSections } from "./sections-ui.js";

export function createSectionsController({
  audio,
  selectTrackByIndex,
  refreshSelectionUi,
  refreshMasteryUi,
  syncPlaybackUi,
  handleError,
}) {
  async function refreshSections() {
    if (!state.currentProfileId) {
      state.allSections = [];
      state.sections = [];
      renderSectionList();
      refreshMasteryUi();
      return;
    }

    const sections = await getSectionsByProfile(state.currentProfileId);
    state.allSections = sections.map(normalizeSectionRecord).sort(sortSections);

    if (!state.allSections.some((section) => section.id === state.focusedSectionId)) {
      state.focusedSectionId = null;
    }

    if (!state.allSections.some((section) => section.id === state.currentPlayingSectionId)) {
      state.currentPlayingSectionId = null;
    }

    renderSectionList();
    refreshMasteryUi();
  }

  function getVisibleSections() {
    const currentTrackName = state.currentTrack?.name;

    if (!currentTrackName) {
      return [];
    }

    return state.allSections.filter((section) => section.trackName === currentTrackName);
  }

  function getActiveVisibleSectionId(visibleSections) {
    if (visibleSections.some((section) => section.id === state.currentPlayingSectionId)) {
      return state.currentPlayingSectionId;
    }

    if (visibleSections.some((section) => section.id === state.focusedSectionId)) {
      return state.focusedSectionId;
    }

    return null;
  }

  function renderSectionList() {
    const visibleSections = getVisibleSections();
    state.sections = visibleSections;

    renderSections({
      sections: visibleSections,
      activeSectionId: getActiveVisibleSectionId(visibleSections),
      currentTrackName: state.currentTrack?.name ?? null,
      onFocus: (sectionId) => {
        void focusSection(sectionId);
      },
      onPlay: (sectionId) => {
        void playSectionById(sectionId);
      },
      onDelete: (sectionId) => {
        void removeSection(sectionId);
      },
    });
  }

  async function saveSelectionAsSection() {
    try {
      if (!state.currentProfileId) {
        window.alert("Select a profile first.");
        return;
      }

      if (!state.currentTrack) {
        window.alert("Pick a track first.");
        return;
      }

      if (state.selection.start == null || state.selection.end == null) {
        window.alert("Drag on the waveform to mark a section before saving.");
        return;
      }

      const start = Math.min(state.selection.start, state.selection.end);
      const end = Math.max(state.selection.start, state.selection.end);

      if (Math.abs(end - start) < 0.05) {
        window.alert("The selected section is too short.");
        return;
      }

      const sectionId = await addSection({
        profileId: state.currentProfileId,
        trackName: state.currentTrack.name,
        start,
        end,
        playCount: 0,
        mastery: 0,
        lastPlayed: 0,
        createdAt: Date.now(),
      });

      state.focusedSectionId = sectionId;
      await refreshSections();
    } catch (error) {
      handleError(error);
    }
  }

  async function focusSection(sectionId) {
    try {
      const section = state.allSections.find((item) => item.id === sectionId);

      if (!section) {
        return;
      }

      state.focusedSectionId = section.id;
      state.selection = {
        start: section.start,
        end: section.end,
      };

      const matchingTrackIndex = state.tracks.findIndex((track) => track.name === section.trackName);

      if (matchingTrackIndex !== -1 && state.currentTrack?.name !== section.trackName) {
        await selectTrackByIndex(matchingTrackIndex, { preserveSelection: true });
      }

      refreshSelectionUi();
      renderSectionList();
      refreshMasteryUi();
    } catch (error) {
      handleError(error);
    }
  }

  async function ensureTrackLoadedForSection(section) {
    const trackIndex = state.tracks.findIndex((track) => track.name === section.trackName);

    if (trackIndex === -1) {
      window.alert(
        `Track "${section.trackName}" is not available in the currently selected folder.`,
      );
      return false;
    }

    if (state.currentTrack?.name !== section.trackName) {
      await selectTrackByIndex(trackIndex, { preserveSelection: true });
    }

    return true;
  }

  async function playSectionById(sectionId) {
    try {
      const section = state.allSections.find((item) => item.id === sectionId);

      if (!section) {
        return;
      }

      const ready = await ensureTrackLoadedForSection(section);

      if (!ready) {
        return;
      }

      state.currentPlayingSectionId = section.id;
      state.focusedSectionId = section.id;
      state.selection = {
        start: section.start,
        end: section.end,
      };

      refreshSelectionUi();
      renderSectionList();
      refreshMasteryUi();

      audio.currentTime = section.start;
      syncPlaybackUi();
      await audio.play();
    } catch (error) {
      handleError(error);
    }
  }

  async function playAdaptiveSection() {
    try {
      if (!state.allSections.length) {
        window.alert("There are no saved sections for this profile yet.");
        return;
      }

      const nextSection = chooseAdaptiveSection(state.allSections);

      if (!nextSection) {
        return;
      }

      await playSectionById(nextSection.id);
    } catch (error) {
      handleError(error);
    }
  }

  async function handleAudioBoundary() {
    if (!state.currentPlayingSectionId) {
      return;
    }

    const activeSection = state.allSections.find(
      (section) => section.id === state.currentPlayingSectionId,
    );

    if (!activeSection) {
      return;
    }

    if (audio.currentTime < activeSection.end) {
      return;
    }

    if (elements.loopToggle.checked) {
      audio.currentTime = activeSection.start;
      syncPlaybackUi();
      return;
    }

    audio.pause();
    audio.currentTime = activeSection.end;
    syncPlaybackUi();

    const completedSectionId = state.currentPlayingSectionId;
    state.currentPlayingSectionId = null;
    renderSectionList();

    await finalizeSectionPlay(completedSectionId);
  }

  async function finalizeSectionPlay(sectionId) {
    const section = state.allSections.find((item) => item.id === sectionId);

    if (!section) {
      return;
    }

    const now = Date.now();
    const updatedSection = {
      ...section,
      playCount: section.playCount + 1,
      lastPlayed: now,
      mastery: calculateMastery(section, now),
    };

    await updateSection(updatedSection);
    await addPlayLog({
      sectionId,
      timestamp: now,
      speed: audio.playbackRate,
    });

    state.focusedSectionId = sectionId;
    await refreshSections();
  }

  async function removeSection(sectionId) {
    try {
      const section = state.allSections.find((item) => item.id === sectionId);

      if (!section) {
        return;
      }

      const confirmed = window.confirm(`Delete section ${createSectionLabel(section)}?`);

      if (!confirmed) {
        return;
      }

      if (state.currentPlayingSectionId === sectionId) {
        audio.pause();
        state.currentPlayingSectionId = null;
      }

      if (state.focusedSectionId === sectionId) {
        state.focusedSectionId = null;
      }

      await deleteSection(sectionId);
      await refreshSections();
    } catch (error) {
      handleError(error);
    }
  }

  return {
    refreshSections,
    renderSectionList,
    saveSelectionAsSection,
    focusSection,
    playSectionById,
    playAdaptiveSection,
    handleAudioBoundary,
    removeSection,
  };
}
</file>

<file path="src/features/sections/sections-ui.js">
/**
 * @role renderer
 * @owns selection display, mastery display, section summary messaging, and saved-section list rendering
 * @not-owns section state transitions, persistence, or playback rules
 * @notes Keep this file presentation-only.
 */

import { elements } from "../../shared/shell-ui.js";
import { createSectionLabel, formatTime } from "../../shared/utils.js";

export function setSelectionDisplay(start, end) {
  elements.abDisplay.textContent = `A ${formatTime(start)} • B ${formatTime(end)}`;
}

export function setMasteryDisplay(value) {
  elements.masteryDisplay.textContent = Number.isFinite(value) ? value.toFixed(2) : "—";
}

export function renderSections({
  sections,
  activeSectionId,
  currentTrackName,
  onFocus,
  onPlay,
  onDelete,
}) {
  elements.sectionList.innerHTML = "";

  if (!currentTrackName) {
    elements.sectionSummary.textContent = "Select a track to view saved sections for that track.";

    const empty = document.createElement("div");
    empty.className = "empty-state";
    empty.textContent = "Select a track to browse and manage its saved sections.";
    elements.sectionList.appendChild(empty);
    return;
  }

  elements.sectionSummary.textContent = sections.length
    ? `Showing ${sections.length} saved section${sections.length === 1 ? "" : "s"} for ${currentTrackName}.`
    : `No saved sections for ${currentTrackName} yet.`;

  if (!sections.length) {
    const empty = document.createElement("div");
    empty.className = "empty-state";
    empty.textContent = "Drag on the waveform to select a range, then save it as a section for this track.";
    elements.sectionList.appendChild(empty);
    return;
  }

  sections.forEach((section) => {
    const row = document.createElement("div");
    row.className = "section-row";
    if (section.id === activeSectionId) {
      row.classList.add("is-active");
    }

    const main = document.createElement("div");
    main.className = "section-main";

    const title = document.createElement("div");
    title.className = "section-title";
    title.textContent = createSectionLabel(section);

    const meta = document.createElement("div");
    meta.className = "section-meta";
    meta.textContent =
      `${section.trackName} • plays ${section.playCount} • mastery ${section.mastery.toFixed(2)} • ` +
      `last played ${section.lastPlayed ? new Date(section.lastPlayed).toLocaleString() : "never"}`;

    main.appendChild(title);
    main.appendChild(meta);

    const actions = document.createElement("div");
    actions.className = "section-actions";

    const playButton = document.createElement("button");
    playButton.type = "button";
    playButton.textContent = "Play";
    playButton.addEventListener("click", (event) => {
      event.stopPropagation();
      onPlay(section.id);
    });

    const deleteButton = document.createElement("button");
    deleteButton.type = "button";
    deleteButton.className = "danger";
    deleteButton.textContent = "Delete";
    deleteButton.addEventListener("click", (event) => {
      event.stopPropagation();
      onDelete(section.id);
    });

    actions.appendChild(playButton);
    actions.appendChild(deleteButton);

    row.appendChild(main);
    row.appendChild(actions);
    row.addEventListener("click", () => onFocus(section.id));

    elements.sectionList.appendChild(row);
  });
}
</file>

<file path="src/features/sections/selection-controller.js">
/**
 * @role controller
 * @owns waveform-driven selection state, mastery display refresh, and selection display refresh
 * @not-owns saved-section persistence, track loading, or profile management
 * @notes Keep this controller focused on selection semantics and related UI.
 */

import { state } from "../../app/state.js";
import { setMasteryDisplay, setSelectionDisplay } from "./sections-ui.js";

export function createSelectionController({ waveform, renderSectionList }) {
  function refreshSelectionUi() {
    waveform.setSelection(state.selection);
    setSelectionDisplay(state.selection.start, state.selection.end);
  }

  function refreshMasteryUi() {
    const focusedSection =
      state.allSections.find((section) => section.id === state.currentPlayingSectionId) ||
      state.allSections.find((section) => section.id === state.focusedSectionId) ||
      null;

    setMasteryDisplay(focusedSection?.mastery ?? null);
  }

  function clearFocusedSectionForManualSelection() {
    if (state.currentPlayingSectionId || state.focusedSectionId == null) {
      return;
    }

    state.focusedSectionId = null;
    renderSectionList();
    refreshMasteryUi();
  }

  function handleWaveformSelectionChange(selection) {
    state.selection = selection;
    setSelectionDisplay(selection.start, selection.end);
    clearFocusedSectionForManualSelection();
  }

  return {
    refreshSelectionUi,
    refreshMasteryUi,
    handleWaveformSelectionChange,
  };
}
</file>

<file path="src/features/tracks/music-folder-store.js">
/**
 * @role persistence-helper
 * @owns persistence and retrieval of remembered folder handle, folder name, and last track name
 * @not-owns folder picking, permission prompts, track enumeration, or UI updates
 * @notes Keep this module storage-focused; controllers should decide behavior.
 */

import { SETTINGS_KEYS } from "../../shared/constants.js";
import { getSetting, setSetting } from "../../persistence/db.js";

export async function getRememberedMusicFolder() {
  const [handle, name, lastTrackName] = await Promise.all([
    getSetting(SETTINGS_KEYS.MUSIC_FOLDER_HANDLE),
    getSetting(SETTINGS_KEYS.MUSIC_FOLDER_NAME),
    getSetting(SETTINGS_KEYS.LAST_TRACK_NAME),
  ]);

  return {
    handle: handle ?? null,
    name: name ?? null,
    lastTrackName: lastTrackName ?? null,
  };
}

export async function rememberMusicFolder(directoryHandle) {
  await Promise.all([
    setSetting(SETTINGS_KEYS.MUSIC_FOLDER_HANDLE, directoryHandle),
    setSetting(SETTINGS_KEYS.MUSIC_FOLDER_NAME, directoryHandle?.name ?? null),
  ]);
}

export async function rememberLastTrackName(trackName) {
  await setSetting(SETTINGS_KEYS.LAST_TRACK_NAME, trackName ?? null);
}
</file>

<file path="src/features/tracks/tracks-controller.js">
/**
 * @role controller
 * @owns folder picking, remembered-folder restore/reconnect, track enumeration, track selection, audio source loading, playback-rate updates, and waveform playback sync
 * @not-owns section CRUD, profile management, or low-level IndexedDB helpers
 * @notes Keep folder persistence delegated to music-folder-store.js.
 */

import { state } from "../../app/state.js";
import { elements } from "../../shared/shell-ui.js";
import { compareByName, isSupportedAudioFile, summarizeTrackCount } from "../../shared/utils.js";
import { renderTracks, setSpeedDisplay, setTrackCount } from "./tracks-ui.js";
import {
  getRememberedMusicFolder,
  rememberLastTrackName,
  rememberMusicFolder,
} from "./music-folder-store.js";

export function createTracksController({
  audio,
  waveform,
  refreshSelectionUi,
  renderSectionList,
  refreshMasteryUi,
  handleError,
}) {
  async function restoreRememberedFolder() {
    try {
      const remembered = await getRememberedMusicFolder();

      if (!remembered.handle) {
        return;
      }

      state.currentFolderHandle = remembered.handle;
      state.currentFolderName = remembered.name || remembered.handle.name || null;

      const permissionState = await queryDirectoryPermission(remembered.handle);

      if (permissionState === "granted") {
        await loadTracksFromDirectory(remembered.handle, {
          preferredTrackName: remembered.lastTrackName,
        });
        return;
      }

      showRememberedFolderStatus();
    } catch (error) {
      console.warn("Unable to restore remembered music folder.", error);
      setTrackCount("No folder selected.");
    }
  }

  async function pickMusicFolder() {
    try {
      if (!window.showDirectoryPicker) {
        throw new Error("This browser does not support folder selection.");
      }

      const remembered = await getRememberedMusicFolder();

      if (state.currentFolderHandle && !state.tracks.length) {
        const permissionState = await queryDirectoryPermission(state.currentFolderHandle);

        if (permissionState === "granted") {
          await loadTracksFromDirectory(state.currentFolderHandle, {
            preferredTrackName: remembered.lastTrackName,
          });
          return;
        }

        const requestedState = await requestDirectoryPermission(state.currentFolderHandle);

        if (requestedState === "granted") {
          await loadTracksFromDirectory(state.currentFolderHandle, {
            preferredTrackName: remembered.lastTrackName,
          });
          return;
        }
      }

      const previousTrackName = state.currentTrack?.name ?? remembered.lastTrackName ?? null;
      const directoryHandle = await window.showDirectoryPicker();

      await rememberSelectedMusicFolder(directoryHandle);
      await loadTracksFromDirectory(directoryHandle, {
        preferredTrackName: previousTrackName,
      });
    } catch (error) {
      handleError(error);
    }
  }

  async function rememberSelectedMusicFolder(directoryHandle) {
    state.currentFolderHandle = directoryHandle;
    state.currentFolderName = directoryHandle.name ?? null;
    await rememberMusicFolder(directoryHandle);
  }

  async function loadTracksFromDirectory(directoryHandle, { preferredTrackName = null } = {}) {
    const nextTracks = [];

    for await (const [name, handle] of directoryHandle.entries()) {
      if (handle.kind !== "file" || !isSupportedAudioFile(name)) {
        continue;
      }

      const file = await handle.getFile();
      nextTracks.push({ name, file });
    }

    nextTracks.sort(compareByName);
    state.tracks = nextTracks;

    renderTracks(state.tracks, null);
    setTrackCount(summarizeTrackCount(nextTracks.length));

    if (!nextTracks.length) {
      clearCurrentTrack();
      return;
    }

    const nextIndex = preferredTrackName
      ? nextTracks.findIndex((track) => track.name === preferredTrackName)
      : 0;

    await selectTrackByIndex(nextIndex >= 0 ? nextIndex : 0);
  }

  async function queryDirectoryPermission(directoryHandle) {
    if (!directoryHandle?.queryPermission) {
      return "prompt";
    }

    return directoryHandle.queryPermission({ mode: "read" });
  }

  async function requestDirectoryPermission(directoryHandle) {
    if (!directoryHandle?.requestPermission) {
      return "granted";
    }

    return directoryHandle.requestPermission({ mode: "read" });
  }

  function showRememberedFolderStatus() {
    const folderName = state.currentFolderName
      ? `Remembered folder: ${state.currentFolderName}.`
      : "Folder remembered.";
    setTrackCount(`${folderName} Click Pick Music Folder to reconnect.`);
  }

  async function selectTrackByIndex(index, { preserveSelection = false } = {}) {
    const track = state.tracks[index];

    if (!track) {
      return;
    }

    audio.pause();
    state.currentPlayingSectionId = null;
    state.currentTrack = track;

    if (!preserveSelection) {
      state.selection = { start: null, end: null };
      state.focusedSectionId = null;
    }

    renderTracks(state.tracks, track.name);

    await Promise.all([loadAudioFile(track.file), waveform.loadFile(track.file)]);
    await rememberLastTrackName(track.name);
    syncWaveformPlaybackPosition();

    refreshSelectionUi();
    renderSectionList();
    refreshMasteryUi();
  }

  function clearCurrentTrack() {
    audio.pause();
    state.currentPlayingSectionId = null;
    state.currentTrack = null;
    state.selection = { start: null, end: null };
    state.focusedSectionId = null;

    releaseCurrentTrackUrl();
    audio.removeAttribute("src");
    audio.load();

    waveform.clear();
    renderTracks(state.tracks, null);
    refreshSelectionUi();
    renderSectionList();
    refreshMasteryUi();
  }

  async function loadAudioFile(file) {
    releaseCurrentTrackUrl();

    const objectUrl = URL.createObjectURL(file);
    state.currentTrackUrl = objectUrl;

    await new Promise((resolve, reject) => {
      const onLoadedMetadata = () => {
        cleanup();
        resolve();
      };

      const onError = () => {
        cleanup();
        reject(audio.error || new Error(`Unable to load audio file "${file.name}".`));
      };

      const cleanup = () => {
        audio.removeEventListener("loadedmetadata", onLoadedMetadata);
        audio.removeEventListener("error", onError);
      };

      audio.addEventListener("loadedmetadata", onLoadedMetadata);
      audio.addEventListener("error", onError);

      audio.src = objectUrl;
      audio.load();
    });

    audio.playbackRate = Number(elements.speed.value);
  }

  function releaseCurrentTrackUrl() {
    if (!state.currentTrackUrl) {
      return;
    }

    URL.revokeObjectURL(state.currentTrackUrl);
    state.currentTrackUrl = null;
  }

  function setSpeed(value) {
    audio.playbackRate = value;
    setSpeedDisplay(value);
  }

  function syncWaveformPlaybackPosition() {
    waveform.setPlaybackTime(Number.isFinite(audio.currentTime) ? audio.currentTime : null);
  }

  return {
    restoreRememberedFolder,
    pickMusicFolder,
    selectTrackByIndex,
    clearCurrentTrack,
    releaseCurrentTrackUrl,
    setSpeed,
    syncWaveformPlaybackPosition,
  };
}
</file>

<file path="src/features/tracks/tracks-ui.js">
/**
 * @role renderer
 * @owns track-select rendering, track-count messaging, and speed display rendering
 * @not-owns track loading, folder permissions, or playback behavior
 * @notes Keep this file presentation-only.
 */

import { elements } from "../../shared/shell-ui.js";

export function renderTracks(tracks, currentTrackName) {
  elements.trackSelect.innerHTML = "";

  if (!tracks.length) {
    const option = document.createElement("option");
    option.textContent = "Pick a folder to load tracks";
    option.disabled = true;
    option.selected = true;
    elements.trackSelect.appendChild(option);
    elements.trackSelect.disabled = true;
    return;
  }

  tracks.forEach((track, index) => {
    const option = document.createElement("option");
    option.value = String(index);
    option.textContent = track.name;
    if (track.name === currentTrackName) {
      option.selected = true;
    }
    elements.trackSelect.appendChild(option);
  });

  elements.trackSelect.disabled = false;
}

export function setTrackCount(text) {
  elements.trackCount.textContent = text;
}

export function setSpeedDisplay(value) {
  elements.speedVal.textContent = `${Number(value).toFixed(2)}×`;
}
</file>

<file path="src/shared/shell-ui.js">
/**
 * @role renderer-support
 * @owns DOM element lookup shared across feature renderers and bootstrap wiring
 * @not-owns feature rendering logic, application state transitions, or persistence
 * @notes Keep this file limited to shell-level element access.
 */

function getElement(id) {
  const element = document.getElementById(id);

  if (!element) {
    throw new Error(`Missing required element: #${id}`);
  }

  return element;
}

export const elements = {
  profileSelect: getElement("profileSelect"),
  newProfile: getElement("newProfile"),

  pickFolder: getElement("pickFolder"),
  trackCount: getElement("trackCount"),
  trackSelect: getElement("trackSelect"),

  saveSection: getElement("saveSection"),
  adaptivePlay: getElement("adaptivePlay"),
  loopToggle: getElement("loopToggle"),

  speed: getElement("speed"),
  speedVal: getElement("speedVal"),

  masteryDisplay: getElement("masteryDisplay"),
  abDisplay: getElement("abDisplay"),

  sectionSummary: getElement("sectionSummary"),
  sectionList: getElement("sectionList"),

  waveformMount: getElement("waveformMount"),
  audio: getElement("audio"),
};
</file>

<file path="src/shared/utils.js">
/**
 * @role utility-module
 * @owns pure helpers for formatting, sorting, normalization, clamping, and adaptive-choice logic
 * @not-owns DOM updates, persistence, or mutable application state
 * @notes Prefer adding only side-effect-free helpers here.
 */

import { SUPPORTED_AUDIO_EXTENSIONS } from "./constants.js";

const DAY_MS = 1000 * 60 * 60 * 24;

export function clamp(value, min, max) {
  return Math.min(max, Math.max(min, value));
}

export function isSupportedAudioFile(name) {
  const lower = name.toLowerCase();
  return SUPPORTED_AUDIO_EXTENSIONS.some((extension) => lower.endsWith(extension));
}

export function compareByName(a, b) {
  return a.name.localeCompare(b.name, undefined, {
    numeric: true,
    sensitivity: "base",
  });
}

export function formatTime(totalSeconds) {
  if (!Number.isFinite(totalSeconds)) {
    return "—";
  }

  const mins = Math.floor(totalSeconds / 60);
  const secs = totalSeconds - mins * 60;
  return `${mins}:${secs.toFixed(2).padStart(5, "0")}`;
}

export function createSectionLabel(section) {
  return `${formatTime(section.start)} → ${formatTime(section.end)}`;
}

export function normalizeSectionRecord(section) {
  return {
    ...section,
    playCount: section.playCount ?? 0,
    mastery: section.mastery ?? 0,
    lastPlayed: section.lastPlayed ?? 0,
    createdAt: section.createdAt ?? 0,
  };
}

export function calculateMastery(section, now = Date.now()) {
  const nextPlayCount = (section.playCount ?? 0) + 1;
  const repetitionScore = Math.min(1, nextPlayCount / 10);

  const daysSinceLastPlay = section.lastPlayed
    ? Math.max(0, (now - section.lastPlayed) / DAY_MS)
    : Infinity;

  const recencyScore = Number.isFinite(daysSinceLastPlay) ? 1 / (1 + daysSinceLastPlay) : 0;

  return Number(Math.min(1, 0.5 * repetitionScore + 0.5 * recencyScore).toFixed(2));
}

export function sortSections(a, b) {
  return (
    a.trackName.localeCompare(b.trackName, undefined, {
      numeric: true,
      sensitivity: "base",
    }) ||
    a.start - b.start ||
    a.end - b.end ||
    a.id - b.id
  );
}

export function summarizeTrackCount(count) {
  if (count === 0) {
    return "No audio files found in the selected folder.";
  }

  return `${count} track${count === 1 ? "" : "s"} loaded.`;
}

export function chooseAdaptiveSection(sections) {
  return (
    [...sections].sort(
      (a, b) =>
        a.mastery - b.mastery ||
        a.lastPlayed - b.lastPlayed ||
        a.playCount - b.playCount ||
        a.start - b.start,
    )[0] ?? null
  );
}
</file>

<file path="src/shared/waveform.js">
/**
 * @role renderer
 * @owns waveform decoding, peak caching, canvas rendering, drag selection, and playback-position visualization
 * @not-owns audio playback control, persistence, or section business rules
 * @notes Keep redraws efficient; cache derived waveform data when possible.
 */

import { clamp } from "./utils.js";

const COLORS = {
  background: "#f8fafc",
  waveform: "#cbd5e1",
  playedFill: "rgba(249, 115, 22, 0.12)",
  playheadLine: "#f97316",
  selectionFill: "rgba(59, 130, 246, 0.20)",
  selectionLine: "#2563eb",
  text: "#6b7280",
};

export function createWaveform({ mountEl, onSelectionChange }) {
  const canvas = document.createElement("canvas");
  canvas.className = "waveform-canvas";
  canvas.height = 140;
  canvas.style.touchAction = "none";
  mountEl.appendChild(canvas);

  const ctx = canvas.getContext("2d");

  let audioBuffer = null;
  let selection = { start: null, end: null };
  let playbackTime = null;
  let dragging = false;
  let cachedPeaks = null;
  let cachedPeaksWidth = 0;

  function resize() {
    canvas.width = Math.max(320, Math.floor(mountEl.clientWidth || 320));
    canvas.height = 140;
    draw();
  }

  window.addEventListener("resize", resize);

  canvas.addEventListener("pointerdown", handlePointerDown);
  canvas.addEventListener("pointermove", handlePointerMove);
  canvas.addEventListener("pointerup", handlePointerUp);
  canvas.addEventListener("pointerleave", handlePointerUp);

  resize();

  function getDuration() {
    return audioBuffer?.duration ?? 0;
  }

  function getNormalizedSelection() {
    const duration = getDuration();
    return {
      start: Number.isFinite(selection.start) ? clamp(selection.start, 0, duration) : null,
      end: Number.isFinite(selection.end) ? clamp(selection.end, 0, duration) : null,
    };
  }

  function getNormalizedPlaybackTime() {
    const duration = getDuration();
    return Number.isFinite(playbackTime) ? clamp(playbackTime, 0, duration) : null;
  }

  function drawPlaceholder(message) {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = COLORS.background;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = COLORS.text;
    ctx.font = "14px system-ui, sans-serif";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText(message, canvas.width / 2, canvas.height / 2);
  }

  function xToTime(x) {
    const duration = getDuration();
    if (!duration) {
      return 0;
    }

    return (clamp(x, 0, canvas.width) / canvas.width) * duration;
  }

  function timeToX(time) {
    const duration = getDuration();
    if (!duration) {
      return 0;
    }

    return (clamp(time, 0, duration) / duration) * canvas.width;
  }

  function computePeaks() {
    if (!audioBuffer) {
      cachedPeaks = null;
      cachedPeaksWidth = 0;
      return null;
    }

    if (cachedPeaks && cachedPeaksWidth === canvas.width) {
      return cachedPeaks;
    }

    const channelData = audioBuffer.getChannelData(0);
    const width = canvas.width;
    const step = Math.max(1, Math.ceil(channelData.length / width));
    const peaks = new Array(width);

    for (let x = 0; x < width; x += 1) {
      let min = 1;
      let max = -1;
      const offset = x * step;

      for (let i = 0; i < step; i += 1) {
        const sample = channelData[offset + i];
        if (sample === undefined) {
          break;
        }
        if (sample < min) {
          min = sample;
        }
        if (sample > max) {
          max = sample;
        }
      }

      peaks[x] = { min, max };
    }

    cachedPeaks = peaks;
    cachedPeaksWidth = width;
    return peaks;
  }

  function draw() {
    if (!audioBuffer) {
      drawPlaceholder("Pick a track to see the waveform.");
      return;
    }

    const peaks = computePeaks();
    const amplitude = canvas.height / 2;

    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = COLORS.background;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    ctx.fillStyle = COLORS.waveform;

    for (let x = 0; x < canvas.width; x += 1) {
      const peak = peaks[x];
      ctx.fillRect(x, (1 + peak.min) * amplitude, 1, Math.max(1, (peak.max - peak.min) * amplitude));
    }

    drawPlaybackRegion();
    drawSelection();
    drawPlayhead();
  }

  function drawMarker(time, label) {
    const x = timeToX(time);

    ctx.setLineDash([6, 4]);
    ctx.strokeStyle = COLORS.selectionLine;
    ctx.beginPath();
    ctx.moveTo(x, 0);
    ctx.lineTo(x, canvas.height);
    ctx.stroke();
    ctx.setLineDash([]);

    ctx.fillStyle = COLORS.selectionLine;
    ctx.font = "12px system-ui, sans-serif";
    ctx.textAlign = "left";
    ctx.textBaseline = "top";
    ctx.fillText(label, Math.min(canvas.width - 20, x + 4), 6);
  }

  function drawPlaybackRegion() {
    const currentTime = getNormalizedPlaybackTime();

    if (currentTime == null) {
      return;
    }

    const x = timeToX(currentTime);

    if (x <= 0) {
      return;
    }

    ctx.fillStyle = COLORS.playedFill;
    ctx.fillRect(0, 0, x, canvas.height);
  }

  function drawPlayhead() {
    const currentTime = getNormalizedPlaybackTime();

    if (currentTime == null) {
      return;
    }

    const x = timeToX(currentTime);

    ctx.strokeStyle = COLORS.playheadLine;
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(x, 0);
    ctx.lineTo(x, canvas.height);
    ctx.stroke();
    ctx.lineWidth = 1;
  }

  function drawSelection() {
    const current = getNormalizedSelection();

    if (current.start == null && current.end == null) {
      return;
    }

    if (current.start != null && current.end != null) {
      const startX = timeToX(current.start);
      const endX = timeToX(current.end);

      ctx.fillStyle = COLORS.selectionFill;
      ctx.fillRect(Math.min(startX, endX), 0, Math.abs(endX - startX), canvas.height);
    }

    if (current.start != null) {
      drawMarker(current.start, "A");
    }

    if (current.end != null) {
      drawMarker(current.end, "B");
    }
  }

  function setSelection(nextSelection, { notify = false } = {}) {
    selection = {
      start: Number.isFinite(nextSelection?.start) ? nextSelection.start : null,
      end: Number.isFinite(nextSelection?.end) ? nextSelection.end : null,
    };

    draw();

    if (notify) {
      onSelectionChange?.({ ...getNormalizedSelection() });
    }
  }

  function setPlaybackTime(nextPlaybackTime) {
    playbackTime = Number.isFinite(nextPlaybackTime) ? nextPlaybackTime : null;
    draw();
  }

  async function loadFile(file) {
    drawPlaceholder("Loading waveform…");

    const arrayBuffer = await file.arrayBuffer();
    const AudioContextCtor = window.AudioContext || window.webkitAudioContext;

    if (!AudioContextCtor) {
      audioBuffer = null;
      cachedPeaks = null;
      cachedPeaksWidth = 0;
      drawPlaceholder("Waveform preview is unavailable in this browser.");
      return;
    }

    const audioContext = new AudioContextCtor();

    try {
      audioBuffer = await audioContext.decodeAudioData(arrayBuffer.slice(0));
      playbackTime = 0;
      cachedPeaks = null;
      cachedPeaksWidth = 0;
    } finally {
      if (audioContext.close) {
        await audioContext.close();
      }
    }

    draw();
  }

  function clear() {
    audioBuffer = null;
    selection = { start: null, end: null };
    playbackTime = null;
    cachedPeaks = null;
    cachedPeaksWidth = 0;
    draw();
  }

  function handlePointerDown(event) {
    if (!audioBuffer) {
      return;
    }

    canvas.setPointerCapture(event.pointerId);
    dragging = true;

    const rect = canvas.getBoundingClientRect();
    const time = xToTime(event.clientX - rect.left);

    setSelection({ start: time, end: time }, { notify: true });
  }

  function handlePointerMove(event) {
    if (!dragging || !audioBuffer) {
      return;
    }

    const rect = canvas.getBoundingClientRect();
    const time = xToTime(event.clientX - rect.left);

    setSelection({ start: selection.start, end: time }, { notify: true });
  }

  function handlePointerUp(event) {
    if (dragging && canvas.hasPointerCapture(event.pointerId)) {
      canvas.releasePointerCapture(event.pointerId);
    }

    dragging = false;
  }

  return {
    clear,
    loadFile,
    setPlaybackTime,
    setSelection,
    getSelection: () => ({ ...getNormalizedSelection() }),
  };
}
</file>

<file path="repomix.config.json">
{
  "$schema": "https://repomix.com/schemas/latest/schema.json",
  "output": {
    "filePath": "repo-context.xml",
    "style": "xml",
    "instructionFilePath": "repomix-instruction.md",
    "fileSummary": true,
    "directoryStructure": true,
    "files": true,
    "removeComments": false,
    "removeEmptyLines": false,
    "includeEmptyDirectories": false,
    "git": {
      "sortByChanges": true,
      "includeDiffs": false,
      "includeLogs": false
    }
  },
  "include": ["**/*"],
  "ignore": {
    "useGitignore": true,
    "useDefaultPatterns": true,
    "customPatterns": [
      "dist",
      "repo-context.xml"
    ]
  },
  "security": {
    "enableSecurityCheck": true
  },
  "tokenCount": {
    "encoding": "o200k_base"
  }
}
</file>

<file path="src/app/bootstrap.js">
/**
 * @role composition-root
 * @owns app bootstrap, controller composition, DOM event wiring, and global error handling
 * @not-owns business logic for profiles, tracks, sections, activities, or persistence
 * @notes Keep this file thin; push feature logic into dedicated modules.
 */

import { openDatabase } from "../persistence/db.js";
import { elements } from "../shared/shell-ui.js";
import { renderTracks, setTrackCount } from "../features/tracks/tracks-ui.js";
import { createProfilesController } from "../features/profiles/profiles-controller.js";
import { createSectionsController } from "../features/sections/sections-controller.js";
import { createSelectionController } from "../features/sections/selection-controller.js";
import { createTracksController } from "../features/tracks/tracks-controller.js";
import { createWaveform } from "../shared/waveform.js";

const audio = elements.audio;

let selectionController;
let sectionsController;
let tracksController;

const waveform = createWaveform({
  mountEl: elements.waveformMount,
  onSelectionChange: (selection) => {
    selectionController.handleWaveformSelectionChange(selection);
  },
});

selectionController = createSelectionController({
  waveform,
  renderSectionList: () => sectionsController.renderSectionList(),
});

tracksController = createTracksController({
  audio,
  waveform,
  refreshSelectionUi: () => selectionController.refreshSelectionUi(),
  renderSectionList: () => sectionsController.renderSectionList(),
  refreshMasteryUi: () => selectionController.refreshMasteryUi(),
  handleError,
});

sectionsController = createSectionsController({
  audio,
  selectTrackByIndex: (...args) => tracksController.selectTrackByIndex(...args),
  refreshSelectionUi: () => selectionController.refreshSelectionUi(),
  refreshMasteryUi: () => selectionController.refreshMasteryUi(),
  syncPlaybackUi: () => tracksController.syncWaveformPlaybackPosition(),
  handleError,
});

const profilesController = createProfilesController({
  refreshSections: () => sectionsController.refreshSections(),
  handleError,
});

bindEvents();
bootstrap().catch(handleError);

async function bootstrap() {
  await openDatabase();
  await profilesController.ensureDefaultProfile();

  renderTracks([], null);
  setTrackCount("No folder selected.");
  tracksController.setSpeed(Number(elements.speed.value));

  await profilesController.refreshProfiles();
  await tracksController.restoreRememberedFolder();
  selectionController.refreshSelectionUi();
}

function bindEvents() {
  elements.profileSelect.addEventListener("change", async (event) => {
    profilesController.setCurrentProfileId(Number(event.target.value));
    await sectionsController.refreshSections();
  });

  elements.newProfile.addEventListener("click", () => {
    void profilesController.createProfile();
  });

  elements.pickFolder.addEventListener("click", () => {
    void tracksController.pickMusicFolder();
  });

  elements.trackSelect.addEventListener("change", (event) => {
    const nextIndex = Number(event.target.value);
    void tracksController.selectTrackByIndex(nextIndex);
  });

  elements.saveSection.addEventListener("click", () => {
    void sectionsController.saveSelectionAsSection();
  });

  elements.adaptivePlay.addEventListener("click", () => {
    void sectionsController.playAdaptiveSection();
  });

  elements.speed.addEventListener("input", (event) => {
    tracksController.setSpeed(Number(event.target.value));
  });

  audio.addEventListener("timeupdate", () => {
    tracksController.syncWaveformPlaybackPosition();
    void sectionsController.handleAudioBoundary();
  });

  audio.addEventListener("loadedmetadata", () => {
    tracksController.syncWaveformPlaybackPosition();
  });

  audio.addEventListener("seeked", () => {
    tracksController.syncWaveformPlaybackPosition();
  });

  audio.addEventListener("pause", () => {
    tracksController.syncWaveformPlaybackPosition();
  });

  audio.addEventListener("ended", () => {
    tracksController.syncWaveformPlaybackPosition();
  });

  window.addEventListener("unload", () => {
    tracksController.releaseCurrentTrackUrl();
  });
}

function handleError(error) {
  if (!error || error.name === "AbortError") {
    return;
  }

  console.error(error);
  window.alert(error.message || "Something went wrong.");
}
</file>

<file path="src/app/router.js">
/**
 * @role route-coordinator
 * @owns surface-level route state and route transitions between workspace, Today list, and practice mode
 * @not-owns feature-specific rendering or persistence
 * @notes The current implementation keeps route state lightweight until additional surfaces are wired.
 */

import { state } from "./state.js";

export const ROUTES = {
  WORKSPACE: "workspace",
  TODAY_LIST: "today-list",
  PRACTICE_MODE: "practice-mode",
};

const VALID_ROUTES = new Set(Object.values(ROUTES));
</file>

<file path="src/app/state.js">
/**
 * @role shared-runtime-state
 * @owns in-memory application state shared across features
 * @not-owns persistence, validation rules, or DOM rendering
 * @notes Keep this as plain data; behavior belongs in controllers or helpers.
 */

export const state = {
  profiles: [],
  currentProfileId: null,

  currentFolderHandle: null,
  currentFolderName: null,
  tracks: [],
  currentTrack: null,
  currentTrackUrl: null,

  allSections: [],
  sections: [],
  selection: {
    start: null,
    end: null,
  },
  focusedSectionId: null,
  currentPlayingSectionId: null,

  activities: [],
};
</file>

<file path="src/persistence/activity-store.js">
/**
 * @role persistence-helper
 * @owns activity-specific IndexedDB access
 * @not-owns activity validation, UI behavior, or practice execution
 * @notes Keep this module storage-focused; controllers should decide behavior.
 */

import { STORES } from "../shared/constants.js";
import { runRequest } from "./db.js";

export function getActivitiesByProfile(profileId) {
  return runRequest(STORES.ACTIVITIES, "readonly", (store) =>
    store.index("byProfileId").getAll(IDBKeyRange.only(profileId)),
  );
}

export function getActivityById(activityId) {
  return runRequest(STORES.ACTIVITIES, "readonly", (store) => store.get(activityId));
}

export function addActivity(activity) {
  return runRequest(STORES.ACTIVITIES, "readwrite", (store) => store.add(activity));
}

export function updateActivity(activity) {
  return runRequest(STORES.ACTIVITIES, "readwrite", (store) => store.put(activity));
}

export function deleteActivity(activityId) {
  return runRequest(STORES.ACTIVITIES, "readwrite", (store) => store.delete(activityId));
}
</file>

<file path="src/persistence/db.js">
/**
 * @role persistence-layer
 * @owns IndexedDB opening, upgrades, transactions, and shared store helpers
 * @not-owns business rules, UI updates, or controller orchestration
 * @notes Preserve compatibility with existing user data whenever possible.
 */

import { DB_NAME, DB_VERSION, STORES } from "../shared/constants.js";

let dbPromise = null;

export function openDatabase() {
  if (dbPromise) {
    return dbPromise;
  }

  dbPromise = new Promise((resolve, reject) => {
    const request = indexedDB.open(DB_NAME, DB_VERSION);

    request.onupgradeneeded = (event) => {
      const database = event.target.result;
      const transaction = event.target.transaction;

      const profilesStore = database.objectStoreNames.contains(STORES.PROFILES)
        ? transaction.objectStore(STORES.PROFILES)
        : database.createObjectStore(STORES.PROFILES, {
            keyPath: "id",
            autoIncrement: true,
          });

      const sectionsStore = database.objectStoreNames.contains(STORES.SECTIONS)
        ? transaction.objectStore(STORES.SECTIONS)
        : database.createObjectStore(STORES.SECTIONS, {
            keyPath: "id",
            autoIncrement: true,
          });

      const playsStore = database.objectStoreNames.contains(STORES.PLAYS)
        ? transaction.objectStore(STORES.PLAYS)
        : database.createObjectStore(STORES.PLAYS, {
            keyPath: "id",
            autoIncrement: true,
          });

      if (!database.objectStoreNames.contains(STORES.SETTINGS)) {
        database.createObjectStore(STORES.SETTINGS, {
          keyPath: "key",
        });
      }

      const activitiesStore = database.objectStoreNames.contains(STORES.ACTIVITIES)
        ? transaction.objectStore(STORES.ACTIVITIES)
        : database.createObjectStore(STORES.ACTIVITIES, {
            keyPath: "id",
            autoIncrement: true,
          });

      if (!profilesStore.indexNames.contains("byName")) {
        profilesStore.createIndex("byName", "name", { unique: false });
      }

      if (!sectionsStore.indexNames.contains("byProfileId")) {
        sectionsStore.createIndex("byProfileId", "profileId", { unique: false });
      }

      if (!sectionsStore.indexNames.contains("byProfileAndTrack")) {
        sectionsStore.createIndex("byProfileAndTrack", ["profileId", "trackName"], {
          unique: false,
        });
      }

      if (!playsStore.indexNames.contains("bySectionId")) {
        playsStore.createIndex("bySectionId", "sectionId", { unique: false });
      }

      if (!activitiesStore.indexNames.contains("byProfileId")) {
        activitiesStore.createIndex("byProfileId", "profileId", { unique: false });
      }

      if (!activitiesStore.indexNames.contains("byProfileAndTargetType")) {
        activitiesStore.createIndex("byProfileAndTargetType", ["profileId", "targetType"], {
          unique: false,
        });
      }
    };

    request.onsuccess = () => resolve(request.result);
    request.onerror = () => reject(request.error);
  });

  return dbPromise;
}

export function runRequest(storeName, mode, action) {
  return openDatabase().then(
    (database) =>
      new Promise((resolve, reject) => {
        const transaction = database.transaction(storeName, mode);
        const store = transaction.objectStore(storeName);
        let request;
        let result;

        try {
          request = action(store);
        } catch (error) {
          reject(error);
          return;
        }

        if (request) {
          request.onsuccess = () => {
            result = request.result;
          };
          request.onerror = () => reject(request.error);
        }

        transaction.oncomplete = () => resolve(result);
        transaction.onerror = () =>
          reject(transaction.error || request?.error || new Error("IndexedDB transaction failed."));
        transaction.onabort = () =>
          reject(transaction.error || request?.error || new Error("IndexedDB transaction aborted."));
      }),
  );
}

export function getAllProfiles() {
  return runRequest(STORES.PROFILES, "readonly", (store) => store.getAll());
}

export function addProfile(profile) {
  return runRequest(STORES.PROFILES, "readwrite", (store) => store.add(profile));
}

export function getSectionsByProfile(profileId) {
  return runRequest(STORES.SECTIONS, "readonly", (store) =>
    store.index("byProfileId").getAll(IDBKeyRange.only(profileId)),
  );
}

export function addSection(section) {
  return runRequest(STORES.SECTIONS, "readwrite", (store) => store.add(section));
}

export function updateSection(section) {
  return runRequest(STORES.SECTIONS, "readwrite", (store) => store.put(section));
}

export function deleteSection(sectionId) {
  return runRequest(STORES.SECTIONS, "readwrite", (store) => store.delete(sectionId));
}

export function addPlayLog(play) {
  return runRequest(STORES.PLAYS, "readwrite", (store) => store.add(play));
}

export function getSetting(key) {
  return runRequest(STORES.SETTINGS, "readonly", (store) => store.get(key)).then(
    (record) => record?.value,
  );
}

export function setSetting(key, value) {
  return runRequest(STORES.SETTINGS, "readwrite", (store) => store.put({ key, value }));
}
</file>

<file path="src/shared/constants.js">
/**
 * @role shared-constants
 * @owns database names, schema versions, store names, settings keys, and shared feature constants
 * @not-owns runtime state, persistence behavior, or UI logic
 * @notes Update DB_VERSION only for intentional IndexedDB schema changes.
 */

export const DB_NAME = "suzukiDB_v4";
export const DB_VERSION = 4;

export const STORES = {
  PROFILES: "profiles",
  SECTIONS: "sections",
  PLAYS: "plays",
  SETTINGS: "settings",
  ACTIVITIES: "activities",
};

export const SETTINGS_KEYS = {
  MUSIC_FOLDER_HANDLE: "musicFolderHandle",
  MUSIC_FOLDER_NAME: "musicFolderName",
  LAST_TRACK_NAME: "lastTrackName",
};

export const DEFAULT_PROFILE_NAME = "Default";

export const SUPPORTED_AUDIO_EXTENSIONS = [
  ".mp3",
  ".wav",
  ".m4a",
  ".aac",
  ".ogg",
  ".flac",
];

export const ACTIVITY_TARGET_TYPES = {
  TRACK: "track",
  SECTION: "section",
  CUSTOM: "custom",
};
</file>

<file path=".gitignore">
# @role ignore-rules
# @owns repository-local ignore patterns for generated files and machine-specific clutter
# @not-owns build config, workflow behavior, or architecture guidance
# @notes Keep this file limited to ignore behavior and concise comments.

dist/
.DS_Store
</file>

<file path="styles.css">
/*
 * @role stylesheet
 * @owns presentation, layout, spacing, colors, responsive behavior, and component states
 * @not-owns markup structure or runtime behavior
 * @notes Keep behavioral decisions out of CSS; prefer styling-only changes here.
 */

:root {
  --bg: #f4f6f8;
  --card: #ffffff;
  --card-alt: #f8fafc;
  --primary: #3b82f6;
  --primary-dark: #2563eb;
  --secondary: #e5e7eb;
  --danger: #ef4444;
  --danger-dark: #dc2626;
  --text: #1f2937;
  --muted: #6b7280;
  --border: #e5e7eb;
  --shadow: 0 6px 20px rgba(0, 0, 0, 0.05);
  --radius: 14px;
}

* {
  box-sizing: border-box;
}

body {
  margin: 0;
  padding: 24px;
  background: var(--bg);
  font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
  color: var(--text);
}

.container {
  max-width: 1040px;
  margin: 0 auto;
}

.page-header {
  margin-bottom: 20px;
}

h1 {
  font-size: 24px;
  margin: 0 0 6px;
  font-weight: 700;
}

h2 {
  font-size: 18px;
  margin: 0;
  font-weight: 650;
}

.card {
  background: var(--card);
  padding: 20px;
  border-radius: var(--radius);
  margin-bottom: 20px;
  box-shadow: var(--shadow);
}

.row {
  display: flex;
  gap: 12px;
  flex-wrap: wrap;
  align-items: center;
  margin-bottom: 12px;
}

.row:last-child {
  margin-bottom: 0;
}

label {
  font-size: 14px;
  color: var(--muted);
  font-weight: 600;
}

select,
input[type="range"] {
  padding: 9px 10px;
  border-radius: 10px;
  border: 1px solid var(--border);
  font-size: 14px;
  background: #fff;
}

select {
  min-width: 220px;
  max-width: 100%;
}

button {
  background: var(--primary);
  color: white;
  border: none;
  padding: 10px 16px;
  border-radius: 10px;
  cursor: pointer;
  font-weight: 600;
  transition: background 0.2s ease, transform 0.1s ease;
}

button:hover {
  background: var(--primary-dark);
}

button:active {
  transform: translateY(1px);
}

button.secondary {
  background: var(--secondary);
  color: var(--text);
}

button.secondary:hover {
  background: #d1d5db;
}

button.danger {
  background: var(--danger);
  color: #fff;
}

button.danger:hover {
  background: var(--danger-dark);
}

button:disabled,
select:disabled,
input:disabled {
  opacity: 0.6;
  cursor: not-allowed;
}

.checkbox-label {
  display: inline-flex;
  align-items: center;
  gap: 8px;
  user-select: none;
}

.waveform-wrap {
  width: 100%;
  margin-top: 12px;
  margin-bottom: 12px;
}

.waveform-canvas {
  width: 100%;
  display: block;
  border: 1px solid var(--border);
  border-radius: 12px;
  background: var(--card-alt);
}

audio {
  width: 100%;
  margin-top: 8px;
  border-radius: 12px;
}

.mastery-pill {
  background: #e0f2fe;
  color: #0369a1;
  padding: 6px 12px;
  border-radius: 999px;
  font-size: 13px;
  font-weight: 700;
}

.section-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 12px;
}

.section-list {
  display: grid;
  gap: 12px;
}

.section-row {
  display: flex;
  justify-content: space-between;
  gap: 12px;
  align-items: center;
  padding: 14px;
  border: 1px solid var(--border);
  border-radius: 12px;
  background: var(--card-alt);
  cursor: pointer;
}

.section-row:hover {
  border-color: #bfdbfe;
  background: #eff6ff;
}

.section-row.is-active {
  border-color: var(--primary);
  background: #dbeafe;
}

.section-main {
  min-width: 0;
}

.section-title {
  font-weight: 700;
  margin-bottom: 4px;
}

.section-meta {
  color: var(--muted);
  font-size: 13px;
  word-break: break-word;
}

.section-actions {
  display: flex;
  gap: 8px;
  flex-wrap: wrap;
}

.empty-state {
  border: 1px dashed var(--border);
  border-radius: 12px;
  padding: 18px;
  color: var(--muted);
  background: var(--card-alt);
}

.small {
  font-size: 13px;
  color: var(--muted);
}

@media (max-width: 720px) {
  body {
    padding: 16px;
  }

  .section-row {
    flex-direction: column;
    align-items: stretch;
  }

  .section-actions {
    justify-content: flex-start;
  }

  select {
    min-width: 0;
    width: 100%;
  }
}
</file>

<file path=".github/workflows/update-repo-context.yml">
# @role workflow
# @owns regeneration and commit-back of repo-context.xml on non-main branch updates
# @not-owns application runtime behavior or repository architecture rules
# @notes Sanitize branch names before using them in artifact names because Git refs may contain characters invalid for artifact naming.

name: Update Repo Context

on:
  push:
    branches-ignore:
      - main
    paths-ignore:
      - repo-context.xml
  workflow_dispatch:

permissions:
  contents: write

concurrency:
  group: update-repo-context-${{ github.ref }}
  cancel-in-progress: true

jobs:
  generate:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout current branch
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 22

      - name: Generate repo context
        run: npx --yes repomix@1.11.1 --config repomix.config.json

      - name: Compute safe artifact name
        shell: bash
        run: |
          raw_ref="${GITHUB_REF_NAME}"
          safe_ref="$(printf '%s' "$raw_ref" | sed 's/[":<>|*?\\/\r\n]/-/g' | sed 's/--*/-/g' | sed 's/^-//' | sed 's/-$//')"

          if [ -z "$safe_ref" ]; then
            safe_ref="unnamed-ref"
          fi

          echo "safe_ref=$safe_ref" >> "$GITHUB_ENV"

      - name: Upload repo context artifact
        uses: actions/upload-artifact@v4
        with:
          name: repo-context-${{ env.safe_ref }}
          path: repo-context.xml

      - name: Commit updated repo context to branch
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git add repo-context.xml

          if git diff --cached --quiet; then
            echo "No repo context changes."
            exit 0
          fi

          git commit -m "chore: refresh repo context"
          git push origin HEAD:${GITHUB_REF_NAME}
</file>

<file path="planning-context.md">
<!--
  @role planning-context
  @owns collaborative planning context, accepted product requirement baseline, current planning delta, decision records, and implementation handoff summaries
  @not-owns repository-wide implementation rules, response-shape rules, and per-file ownership details that belong in repomix-instruction.md or file headers
  @notes Human readability comes first. Treat accepted baseline requirements as stable unless explicitly changed. Do not keep speculative roadmap items here.
-->

# Planning Context

This file is the lightweight planning artifact for this repository.

It exists to support collaborative feature planning before implementation begins. It should stay concise, current, and decision-oriented. It is not a replacement for source code or `repo-context.xml`; it is the planning layer above them.

This file should contain:

* accepted current product requirements
* the actively discussed requirement delta for the current feature
* decisions, tradeoffs, and open questions needed to move the current feature into implementation

This file should **not** contain:

* speculative future roadmap items
* aspirational product vision items that are not part of the currently planned feature
* implementation details, APIs, module structure, or file-level ownership rules

If future ideas are useful during a planning conversation, they may be introduced temporarily in that conversation. They should only be added here if they become part of the currently agreed planning delta.

---

## Purpose

Use this file to:

* describe the product and current UX at a planning level
* capture accepted product requirements and active proposed changes
* document open questions, decisions, and tradeoffs for the current feature
* define feature-specific planning constraints
* create a stable handoff into implementation

Use `repo-context.xml` or file-level code context when the conversation moves from planning into implementation.

---

## Product Summary

This repository contains a browser-based music practice app for section-based repetition and adaptive practice.

Core capabilities currently include:

* selecting a music folder from the local filesystem
* choosing tracks from that folder
* marking A/B points on a waveform
* saving sections per profile
* replaying saved sections
* tracking play count and mastery
* adaptively selecting what to practice next

The product should favor fast practice flow, clear visual feedback, and low-friction continuity.

---

## Product Goals

The app should help a learner practice efficiently by making it easy to:

* load personal practice audio
* identify and save difficult passages
* replay passages repeatedly
* track repetition and progress
* choose what to practice next with minimal friction

The UX should optimize for clarity and speed during active practice.

---

## Source Of Truth

This file is the source of truth for **planning**.

Repository structure, implementation boundaries, code-editing rules, and per-file ownership are defined elsewhere and should not be duplicated here as stable reference material.

Use this file for:

* user-facing behavior
* workflow intent
* state expectations
* requirement status
* open questions
* decisions
* tradeoffs
* feature-specific planning constraints

Do not treat this file as the authoritative source for:

* exact module ownership
* exact file responsibilities
* exact code-editing protocol
* full repository technical constraints

If a planning topic depends on a technical constraint, reference it briefly in the current topic instead of restating the entire repository contract.

---

## Requirement Authoring Rules

Requirements in this file must follow these rules:

* Requirements must be written in terms of user-observable behavior or user-available capability.
* Requirements must not be phrased as implementation details, file structure, APIs, storage mechanisms, browser internals, or module responsibilities.
* Requirements may include an allocation to a product area, but must not be split by code file.
* Requirement IDs remain stable once introduced.
* Accepted baseline requirements should remain conservative and reflect currently accepted product behavior.
* The only future-oriented requirements allowed in this file are the ones in the current planning delta for the feature actively being planned.
* Do not keep speculative roadmap items, dream features, or long-range candidate ideas in this file once the session ends unless they have been explicitly accepted into the current planning delta.

---

## Current Product Regions

The current product is organized around these major regions:

1. Header / app identity
2. Profile controls
3. Folder selection and track selection
4. A/B marking and save controls
5. Playback and loop controls
6. Speed control
7. Waveform display and selection interaction
8. Saved sections list and section actions
9. Reusable activities list and activity actions

---

## Primary User Flows

### 1. Load Music And Choose Track

* User picks a music folder.
* App enumerates supported audio files.
* User selects a track.
* App loads the audio and waveform.

### 2. Create A Saved Section

* User loads a track.
* User marks A and B from waveform drag.
* User saves the selected range as a section under the active profile.

### 3. Focus And Replay A Saved Section

* User loads a track.
* App shows saved sections for the selected track.
* User selects a saved section.
* App focuses the associated time range.
* User plays the section.
* App loops or completes playback according to settings.

### 4. Create A Reusable Activity

* User creates a named activity under the active profile.
* The activity targets either a whole track, a saved section, or a freeform custom reference.
* For track-based and section-based work, the user can create activities quickly from the current workspace context.
* For non-library material, the user can create a named freeform activity directly.

### 5. Use A Playable Activity In The Workspace

* User selects a playable activity from the activity list.
* If the activity targets a whole track, the app loads that track into the workspace.
* If the activity targets a saved section, the app loads the associated track when needed and focuses the section range in the workspace.
* If the target cannot be resolved, the app provides clear feedback.

### 6. Adaptive Practice

* User asks for the next section adaptively.
* App selects a saved section based on low mastery / low recency / low play count.
* App loads the appropriate track and plays the section there.

### 7. Refresh And Resume Context

* User reloads the page.
* App restores persisted context where possible.
* App should preserve continuity without confusing the user.

---

## Product State Model

The most important product-level states are:

### Identity / Scope

* active profile
* saved sections for active profile
* reusable activities for active profile

### Music Source

* no folder known
* folder known but permission not currently granted
* folder available and readable

### Track Context

* no tracks loaded
* tracks loaded
* current track selected
* current track unavailable in current folder

### Selection State

* no selection
* valid waveform range selected

### Playback State

* idle
* playing full track context
* playing saved section
* looping saved section
* paused at position
* ended

### Waveform State

* no waveform loaded
* waveform loading
* waveform visible
* waveform selection active
* playback position visible

### Activity State

* no activities
* activities available
* selected activity
* selected activity playable in the workspace
* selected activity not directly playable in the workspace

---

## Requirement Status Rules

Use these statuses consistently:

* **Implemented**: accepted and already reflected in the code
* **Accepted target**: accepted for the current feature, but implementation is expected to catch up
* **Under discussion**: actively being planned, not yet accepted
* **Deferred**: intentionally postponed within the current feature discussion
* **Rejected**: explicitly not doing this within the current feature discussion

Unless the user explicitly says otherwise:

* implemented requirements remain accepted baseline behavior
* accepted target requirements remain accepted only if they are part of the currently planned feature
* under-discussion items are the only active requirement change surface
* deferred and rejected items should not be silently reintroduced

Deferred or rejected items from a completed planning session should generally be removed from this file unless they remain necessary context for the active feature.

---

## Accepted Product Requirement Baseline

This section records accepted product requirements that should not be reinterpreted by default during future planning sessions.

### Implemented

* **REQ-001 - Profile selection**

  * Allocation: Profiles
  * The user can select a practice profile.

* **REQ-002 - Profile creation**

  * Allocation: Profiles
  * The user can create a new practice profile.

* **REQ-003 - Profile-scoped saved work**

  * Allocation: Profiles
  * Saved sections and related practice state are scoped to the active profile.

* **REQ-004 - Music folder selection**

  * Allocation: Music source
  * The user can choose a local music folder as the source of practice tracks.

* **REQ-005 - Supported audio track loading**

  * Allocation: Music source
  * The app loads supported audio files from the selected folder and presents them as selectable tracks.

* **REQ-006 - Folder continuity across refresh**

  * Allocation: Music source
  * The app remembers the previously selected music folder and can reconnect to it after refresh, including showing reconnect guidance when permission is needed again.

* **REQ-007 - Last-track continuity**

  * Allocation: Music source
  * When possible, the app restores or reselects the most recently used track from the remembered music folder.

* **REQ-008 - Track selection**

  * Allocation: Track playback
  * The user can select a loaded track for practice.

* **REQ-009 - Playback speed control**

  * Allocation: Track playback
  * The user can adjust playback speed for the current track.

* **REQ-010 - A/B point marking from playback**

  * Allocation: Selection and waveform
  * The user can mark A and B points using the current playback position.

* **REQ-011 - Waveform-based selection**

  * Allocation: Selection and waveform
  * The user can create or adjust a practice range by dragging on the waveform.

* **REQ-012 - Visible selection feedback**

  * Allocation: Selection and waveform
  * The app displays the current A/B selection clearly in both text form and on the waveform.

* **REQ-013 - Visible playback position on waveform**

  * Allocation: Selection and waveform
  * While a track is loaded, the waveform shows the current playback position and played progress.

* **REQ-014 - Save selected section**

  * Allocation: Saved sections
  * The user can save a valid selected range as a practice section for the current track and profile.

* **REQ-015 - Browse saved sections**

  * Allocation: Saved sections
  * The user can view saved sections for the active profile.

* **REQ-016 - Focus saved section**

  * Allocation: Saved sections
  * The user can select a saved section and have its range become the current focus.

* **REQ-017 - Delete saved section**

  * Allocation: Saved sections
  * The user can delete a saved section.

* **REQ-018 - Play saved section**

  * Allocation: Saved sections
  * The user can play a saved section from its start point.

* **REQ-019 - Loop saved section**

  * Allocation: Saved sections
  * The user can loop playback of a saved section.

* **REQ-020 - Cross-track section playback**

  * Allocation: Saved sections
  * If a saved section belongs to another currently available track, the app can load that track and play the section there.

* **REQ-021 - Practice history tracking**

  * Allocation: Practice adaptation
  * The app tracks section practice activity over time.

* **REQ-022 - Section mastery visibility**

  * Allocation: Practice adaptation
  * The app shows a mastery value for the currently focused or playing section.

* **REQ-023 - Adaptive next-section selection**

  * Allocation: Practice adaptation
  * The user can ask the app to choose the next section to practice adaptively from saved sections in the active profile.

* **REQ-024 - Clear empty and missing-state messaging**

  * Allocation: User feedback and recovery
  * The app provides clear guidance when required prerequisites are missing, such as no folder, no track, no selection, or no saved sections.

* **REQ-025 - Missing-track recovery feedback**

  * Allocation: User feedback and recovery
  * If a saved section refers to a track that is not available in the current folder, the app clearly informs the user.

### Accepted target

* None yet.

---

## Current Planning Delta

This section records only the requirement changes for the feature currently being planned.

### Add

* **REQ-026 - Reusable named practice activities**

  * Allocation: Practice planning
  * The user can create reusable, nameable practice activities scoped to the active profile.

* **REQ-027 - Activity target types**

  * Allocation: Practice planning
  * A practice activity can target a whole track, a saved section, or a freeform custom reference.

* **REQ-028 - Freeform custom activity target**

  * Allocation: Practice planning
  * For non-library practice material, the user can create a named activity by entering a freeform reference instead of choosing an existing track or section.

* **REQ-035 - Browse reusable activities**

  * Allocation: Practice planning
  * The user can view reusable activities for the active profile from the main workspace.

* **REQ-036 - Workspace activity focus**

  * Allocation: Practice planning
  * When an activity targets a whole track or a saved section, the user can use that activity to load and focus the associated track or section in the existing workspace.

### Change

* **REQ-015 - Browse saved sections**

  * Allocation: Saved sections
  * Change from "The user can view saved sections for the active profile" to "The user can view saved sections for the currently selected track within the active profile."

### Remove

* **REQ-010 - A/B point marking from playback**

  * Allocation: Selection and waveform
  * Remove playback-position marker buttons from the main workspace. Waveform interaction becomes the primary way to define A/B selection there.

### Under-discussion items

* None currently blocking this feature slice.

### Deferred

* **REQ-029 - Today practice list**

  * Allocation: Practice planning
  * Deferred to a later slice. The first slice does not add a Today practice list.

* **REQ-030 - Separate practice mode**

  * Allocation: Practice execution
  * Deferred to a later slice. The first slice does not add a separate practice mode.

* **REQ-031 - Workspace and practice navigation**

  * Allocation: Navigation and workflow
  * Deferred to a later slice because the first slice stays within the workspace.

* **REQ-032 - Single-activity practice execution**

  * Allocation: Practice execution
  * Deferred to a later slice. The first slice does not add one-activity-at-a-time practice execution UI.

* **REQ-033 - Playable activity launch**

  * Allocation: Practice execution
  * Deferred to a later slice. Playable activities in the first slice act as workspace shortcuts rather than a separate execution mode.

* **REQ-034 - Lightweight in-practice region selection**

  * Allocation: Practice execution
  * Deferred to a later slice because the first slice does not add practice mode.

* practice categories as first-class user-managed entities

* song sets and set-based activity targets

* structured fields for non-library custom targets beyond the initial freeform reference

* ratings in the first practice-mode slice

* timers and timer-driven stop or notification behavior in the first practice-mode slice

* saving new sections directly from a future practice mode

* cumulative teacher-note backlog UX

* named multi-day practice plans beyond an eventual Today practice list

### Rejected

* overloading sections so they become the universal practice activity model
* keeping separate Mark A and Mark B buttons on the main workspace screen as the primary section-selection flow

---

## Decision Record

Use this section to record resolved planning decisions for the current or most recently completed feature in compact form.

### Accepted Decisions

* The current main screen remains a workspace / planner surface.
* The first slice should stay within the existing workspace rather than introducing a Today practice list or separate practice mode.
* Saved sections should be shown only for the currently selected track in the main workspace.
* Activities are reusable entities and should not be treated as plan-local only.
* Activities should be explicitly nameable in the first slice.
* Sections remain specialized saved passages associated with tracks; they are valid activity targets but are not themselves activities.
* Activity target types for the first slice are track, saved section, and freeform custom reference.
* Quick-add should be favored for track-based and section-based activity creation, while freeform custom activities should still have a direct creation path.
* Freeform is the initial approach for non-library practice material.
* Playable activities in the first slice should function as workspace shortcuts that load or focus the relevant track or section using the existing workspace controls.
* Waveform drag / pointer selection is the intended main workflow for setting A/B ranges in the workspace.

### Rejected Or Deferred Directions

* A dedicated Today practice list was deferred to keep the first slice smaller.
* A separate practice mode was deferred to keep the first slice smaller.
* One-activity-at-a-time execution UI was deferred to keep the first slice smaller.
* In-practice temporary region selection was deferred with practice mode.
* Early introduction of song sets, categories, timers, ratings, and named plans was deferred to keep the first slice incremental.

---

## Open Questions

Use this section as the active planning queue for the current feature only.

* None blocking implementation for the current slice.

---

## Current Planning Focus

Use this section to summarize the feature or problem currently under discussion.

### Problem

* The current app supports track-based section work, but it does not yet support reusable practice activities.
* The current section browse model is profile-wide, which conflicts with the desired track-centric mental model for saved sections.
* The current main workspace still exposes playback-position A/B marker buttons even though waveform selection is the intended interaction model.
* The broader multi-surface planning direction proved too large for the first implementation slice.

### Desired Outcome

* The app should support reusable named practice activities that can point to a whole track, a saved section, or freeform non-library material.
* The first slice should let the user create and browse those activities in the existing workspace.
* For playable activities, the user should be able to use an activity as a shortcut that loads or focuses the associated track or section in the existing workspace.
* The main workspace should stay oriented around track selection, waveform inspection, section management, and activity creation / browsing for the active profile.
* Saved sections in the workspace should be shown only for the currently selected track.
* Playback-position Mark A / Mark B controls should be removed from the workspace in favor of waveform selection.

### Topic-Specific Constraints

* The first slice should build on the existing track, waveform, and section foundation rather than replace it.
* The first slice should stay incremental and avoid introducing too many new domains at once.
* Non-library material should start as a freeform reference rather than a more structured schema.
* The first slice should not add a Today practice list or a separate practice mode.
* The first slice should not turn the workspace into a dedicated one-at-a-time activity execution surface.

### Proposed Direction

* Keep the product on a single workspace surface for this slice.
* Keep sections as track-associated saved passages.
* Make activities the reusable planning object introduced in this slice.
* Support three activity target types in the first slice:

  * whole track
  * saved section
  * freeform custom reference
* Show saved sections only for the currently selected track in the workspace.
* Remove playback-position Mark A / Mark B controls from the main workspace and rely on waveform selection there.
* Favor quick-add flows for creating activities from the current track or a selected section.
* Let playable activities act as shortcuts that load and focus existing workspace state rather than opening a new practice surface.

### Risks / Edge Cases

* A saved-section activity may reference a section that has been deleted.
* A track-targeted or section-targeted activity may reference a track that is unavailable in the currently connected folder.
* A custom activity target may have no playable media, so the workspace must handle both playable and non-playable activities clearly.
* Activity focus in the workspace must not be mistaken for a separate practice mode.
* If no track is selected in the workspace, the section area needs clear messaging that sections are track-specific.
* The workspace needs clear distinction between saved sections and reusable activities so the two concepts do not blur.

### Requirement Impact

* Unchanged baseline requirements: REQ-001 through REQ-009, REQ-011 through REQ-014, REQ-016 through REQ-025.
* Baseline requirements proposed to change: REQ-015.
* Baseline requirements proposed to remove: REQ-010.
* New requirements proposed for the current feature: REQ-026 through REQ-028, REQ-035, and REQ-036.
* Deferred requirements from the larger earlier concept: REQ-029 through REQ-034.
* Open requirement questions: none currently blocking the first slice.

### Definition Of Ready For Implementation

A planning topic is ready to move to implementation when:

* the user-visible behavior is specified
* major edge cases are identified
* success and failure states are described
* the affected requirements are clearly classified as unchanged, changed, added, removed, deferred, or rejected
* the current planning delta is explicit
* no major product-level ambiguity remains

This topic is considered ready to move into implementation for the smaller first slice described in this file.

---

## Implementation Handoff Template

### Feature Summary

* Introduce reusable named practice activities in the existing workspace.
* Re-scope workspace section browsing so it only shows saved sections for the currently selected track.
* Remove playback-position Mark A / Mark B controls from the workspace and rely on waveform selection there.
* Let playable activities act as workspace shortcuts that load or focus the associated track or saved section using the existing workspace controls.

### Requirement Impact

* Unchanged baseline requirements: REQ-001 through REQ-009, REQ-011 through REQ-014, REQ-016 through REQ-025.
* Changed baseline requirements: REQ-015.
* New requirements: REQ-026 through REQ-028, REQ-035, and REQ-036.
* Removed requirements: REQ-010.
* Deferred or rejected items: REQ-029 through REQ-034, first-class categories, song sets, structured non-library targets beyond freeform, timers, ratings, cumulative teacher-note backlog UX, and named multi-day plans.

### User-Facing Behavior

* In the workspace, the user selects a track, sees that track's waveform, and manages only that track's saved sections.
* The user creates reusable named activities that target either a whole track, a saved section, or a freeform custom reference.
* The user can browse reusable activities for the active profile in the workspace.
* When an activity targets a whole track or a saved section, the user can use that activity to load and focus the associated track or section in the existing workspace.
* Freeform activities are visible reusable references but are not directly playable in this first slice.
* The user remains in a single workspace surface rather than navigating into a Today list or separate practice mode.

### Important States And Edge Cases

* no track selected in workspace
* no saved sections for selected track
* no activities for the active profile
* non-playable freeform activity target
* missing track for a track-targeted or section-targeted activity
* deleted section referenced by an activity
* activity focus in the workspace that must remain distinct from any future dedicated practice mode

### Persistence / User Continuity Impact

* Existing profile, folder, track, section, and play-history continuity should remain intact.
* Activities become new profile-scoped persisted planning state.
* Activity targets should continue to respect current music-folder availability constraints when they rely on playable media.
* Workspace continuity remains the primary continuity surface for this slice.

### Likely Implementation Touchpoints

* IndexedDB schema and persistence helpers for activities.
* Main workspace UI and rendering changes for track-only section browsing and removal of Mark A / Mark B buttons.
* New activity list and activity creation UI in the workspace.
* Existing track / waveform / section focus coordination reused for playable activity shortcuts.

### Notes For Implementation

* Keep the first slice incremental and preserve the current section and playback foundation.
* Do not broaden the first slice into a Today list, a separate practice mode, or one-at-a-time practice execution UI.
* Treat freeform custom targets as the initial non-library model.
* Keep the first slice centered on reusable activity creation, browsing, and workspace focus shortcuts.

---

## Planning Heuristics

During planning, emphasize:

* user goals
* user-visible behavior
* workflows
* states and transitions
* edge cases
* error handling
* tradeoffs

De-emphasize:

* exact function names
* exact code structure
* implementation mechanics that do not materially affect planning

A good planning update should answer:

* what should the user see?
* what should happen next?
* what should be remembered?
* what can fail?
* how should failure be presented?
* what is explicitly out of scope?

Prefer plans that are:

* concrete
* compatible with the current app shape
* incremental
* easy to hand off into implementation later

---

## Update Discipline

When editing this file collaboratively:

* keep it cumulative
* remove stale conclusions
* preserve useful context
* avoid transcript-like accumulation
* prefer the current best understanding over historical discussion residue
* update requirement status deliberately rather than implicitly
* do not silently reinterpret accepted baseline requirements
* do not retain speculative future requirements after the planning session unless they are part of the current agreed feature delta

This file should read like a living planning brief, not like chat logs.

---

## Planning Workflow

The default planning workflow for this repository is:

1. The user pastes this file into a chat session and describes the feature, pain point, or desired change.
2. The AI first classifies the request against the accepted baseline:

   * unchanged baseline requirements
   * baseline requirements proposed to change
   * new proposed requirements for the current feature
   * open questions
3. The discussion stays at the product / UX / planning level first.
4. The AI returns cumulative updates to this file.
5. The user and AI iterate until the plan is satisfactory.
6. The updated `planning-context.md` is committed to the repository.
7. The repo context generation flow includes this file in `repo-context.xml`.
8. A later implementation session uses the updated planning context plus relevant code context.

A planning session should usually end with:

* a clear problem statement
* an agreed user-facing behavior
* accepted tradeoffs
* known edge cases
* a concrete handoff into implementation
* a clear requirement delta against the accepted baseline

When the planning session ends:

* requirements that were accepted and implemented should be promoted into the accepted baseline when appropriate
* requirements that were discussed but not accepted should generally be removed from this file
* speculative roadmap ideas should not be retained here unless they are part of the actively agreed feature plan

---

## Instructions To AI

When this file is pasted into a planning chat, follow these rules.

### Role

Act as a collaborative product, UX, and technical planning partner. Optimize for clarity, feasibility, and cumulative decision quality. Do not jump directly into implementation unless the user clearly asks to move into code changes.

### Default Behavior

1. Start from the existing contents of this file.
2. Treat this file as the source of truth for planning unless the user explicitly supersedes part of it.
3. Classify each new request first as:

   * unchanged baseline behavior
   * a modification to accepted baseline requirements
   * a new proposed requirement for the current feature
   * a clarification of an open question
4. Discuss requests first in terms of:

   * user goals
   * pain points
   * workflows
   * states
   * tradeoffs
   * risks
   * open questions
5. Return cumulative file updates rather than isolated patch fragments unless the user explicitly asks for diffs.
6. Prefer updating existing sections over scattering redundant notes.
7. Distinguish clearly between:

   * confirmed facts
   * assumptions
   * recommendations
   * open questions
8. Use repository-wide instructions and actual code context as the source of truth for implementation constraints rather than duplicating them here.

### Baseline And Delta Rules

* Treat items in **Accepted Product Requirement Baseline** as stable unless the user explicitly asks to change them.
* Do not silently renegotiate or reinterpret accepted baseline requirements.
* Use **Current Planning Delta** as the active surface for requirement changes.
* Do not add speculative future requirements, roadmap items, or aspirational ideas to this file unless they are part of the feature currently being planned.
* If the user brings future ideas into the conversation, use them only as discussion input unless the conversation explicitly promotes them into the current planning delta.
* When a requirement changes status, update that status explicitly.
* If a request conflicts with accepted baseline requirements, surface the conflict clearly before proposing edits.

### Requirement Rules

* Requirements must be expressed as user-observable behavior or user-available capability.
* Requirements must not be expressed as implementation details, APIs, data stores, files, classes, modules, or browser internals.
* Requirements may include an allocation to a product area, but must not be split by file.
* Preserve requirement IDs once introduced.

### Collaboration Rules

* Do not treat the first request as a final specification.
* Help the user shape the request into a better plan.
* When the request is underspecified, propose structured options.
* When the request seems risky, weak, or inconsistent, probe constructively and explain the tradeoff rather than dismissing it.
* Prefer decisions that preserve future flexibility unless there is a strong reason not to.
* Stay grounded in the actual product and repository context.

### Output Rules

When proposing an update to this file:

* update relevant sections in place
* keep wording crisp and specific
* remove stale or superseded statements
* avoid duplication
* prefer bullets and short sections over long prose
* keep low-level implementation detail out unless it materially affects planning
* preserve requirement IDs once introduced
* keep the file focused on accepted baseline plus the active feature delta

### Escalation Rule

Stay in planning mode until most of the following are true:

* the user-facing behavior is clear
* the important states and edge cases are identified
* the main tradeoffs are accepted
* the requirement delta is explicit
* the plan is concrete enough to map to implementation

Once those conditions are substantially satisfied, summarize the implementation handoff and only then move into code-editing mode if requested.
</file>

<file path="repomix-instruction.md">
<!--
  @role repository-instructions
  @owns repository-wide AI guidance, implementation-session rules, code-editing response-shape rules, requirement traceability rules, and process rules for keeping ownership metadata current
  @not-owns feature-planning process, planning-session behavior, or per-file implementation details that belong in planning-context.md or file headers
  @notes For comment-capable files, file headers are the authoritative source of per-file ownership. planning-context.md is the authoritative source for accepted product requirements and active feature deltas.
-->

# Repository Instructions

## How this repository is used with AI

The repository uses two distinct artifacts for AI-assisted work:

- `planning-context.md` for accepted product requirements and the currently agreed feature delta
- `repo-context.xml` for implementation-oriented repository context

In implementation sessions:

1. A generated `repo-context.xml` file is pasted into a chat session.
2. The user asks for a feature, bug fix, or refactor.
3. The AI uses the repository context together with `planning-context.md`, when present, to understand accepted requirements and the active feature delta.
4. Respond with complete file contents for every file that changes.
5. Do not return diff hunks unless explicitly requested.
6. Preserve the automated `repo-context.xml` workflow unless the request explicitly changes it.

## Source of truth

Use the following ownership split:

- `planning-context.md` is the source of truth for product requirements, including the accepted baseline and any currently agreed feature delta.
- `repomix-instruction.md` is the source of truth for repository-wide implementation rules, response shape, requirement traceability rules, and maintenance conventions.
- File headers are the source of truth for per-file ownership for comment-capable files.
- The current codebase remains the source of truth for actual implementation details.

Do not treat speculative ideas, aspirational roadmap items, or earlier conversational brainstorming as requirements unless they have been explicitly accepted into `planning-context.md`.

## Repo constraints

- This is a static browser app with no build step.
- `index.html` contains markup only.
- `styles.css` contains styling only.
- Prefer browser-native APIs over added dependencies.
- Preserve compatibility with the existing IndexedDB database when possible.
- File-level ownership rules live in file headers for comment-capable files and are the authoritative source for deciding where changes belong.
- Comment-capable files include source files, stylesheets, HTML files, workflow YAML files, markdown instruction files, and repository dotfiles such as `.gitignore`.
- `repomix.config.json` is a strict JSON file and should not receive comment headers; if it ever needs architectural notes, document them here.

## Use of planning context during implementation

When `planning-context.md` is present in the implementation context:

- treat accepted baseline requirements as stable unless the user explicitly asks to change them
- treat the current planning delta as the only active requirement change surface
- use requirement IDs, statuses, and allocations from `planning-context.md` when available
- preserve the distinction between unchanged baseline requirements and feature-specific changes
- do not silently reinterpret or renegotiate accepted requirements during implementation

If implementation reveals that an accepted requirement is infeasible, contradictory, or materially more complex than expected:

- say so explicitly
- identify the affected requirement
- explain the constraint or tradeoff
- ask to update planning rather than silently changing behavior

## Requirement definition and traceability

Product requirements are defined in `planning-context.md`.

Requirements must be:
- expressed as user-observable behavior or user-available capability
- implementation-agnostic
- stable across refactors
- allocated to product areas if helpful, but not split by code file

Requirements must not be defined as:
- file responsibilities
- modules, classes, functions, APIs, or data stores
- browser or storage implementation details
- internal architecture choices

File headers may include requirement traceability metadata, such as requirement IDs affected by that file.

Requirement traceability in file headers is for implementation mapping only. File headers do not define or redefine product requirements.

## File header convention

For comment-capable files, keep a short header at the top of the file using this shape:

- `@role`: what kind of module or file this is
- `@owns`: what this file is responsible for
- `@not-owns`: what should be changed elsewhere
- `@reqs`: optional requirement IDs this file materially contributes to
- `@notes`: optional short maintenance guidance

Keep headers concise and high-signal. Do not turn them into long prose blocks.

Use `@reqs` for requirement traceability only. Do not use it to redefine product requirements or to imply that requirements are owned by individual files.

## Keeping ownership metadata current

- When adding, removing, renaming, or moving a comment-capable file, update its header in the same change.
- When introducing a new architectural component such as a controller, store, service, renderer, adapter, or utility module, add or update the relevant file header immediately.
- When a file’s responsibility changes materially, update its `@owns` and `@not-owns` header entries in the same change.
- When a file materially begins or stops contributing to a traced requirement, update its `@reqs` metadata in the same change if that metadata is present in the repository.
- When a new file becomes part of the regular edit surface for future work, give it a header when the file format supports comments.
- Apply the same header discipline to comment-capable non-code files, including workflow files, markdown docs, and repository dotfiles.
- If a file format does not support comments, keep any necessary ownership guidance here in `repomix-instruction.md`.
- Treat this instruction file as the source of repository-wide rules, and treat file headers as the source of per-file ownership rules and optional requirement traceability.

## Change preferences

- Favor small, composable modules over a single large file.
- Avoid frameworks and build tooling unless explicitly requested.
- Keep the app easy to edit by copy/pasting full files from chat responses.
- Minimize comprehensive refactors, but if a change drives a reorganization propose the minimal sensible refactor.

## Expected response shape for code changes

- Group output by file path.
- Return the full contents of each changed file.
- Keep explanations brief unless the user asks for deeper design rationale.
</file>

<file path="index.html">
<!doctype html>
<!--
  @role document-shell
  @owns static markup, semantic structure, and script/style entrypoints
  @not-owns runtime behavior or styling rules beyond structural classes and ids
  @notes Keep this file markup-only.
-->
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Suzuki Practice Partner</title>
  <link rel="stylesheet" href="./styles.css" />
</head>
<body>
  <div class="container">
    <header class="page-header">
      <h1>Suzuki Practice Partner</h1>
      <p class="small">
        Waveform-driven section practice with profiles, repeat tracking, and adaptive playback.
      </p>
    </header>

    <section class="card">
      <div class="row">
        <label for="profileSelect">Profile</label>
        <select id="profileSelect" aria-label="Profile"></select>
        <button id="newProfile" type="button" class="secondary">New Profile</button>
      </div>
    </section>

    <section class="card">
      <div class="row">
        <button id="pickFolder" type="button">Pick Music Folder</button>
        <span id="trackCount" class="small">No folder selected.</span>
      </div>

      <div class="row">
        <label for="trackSelect">Track</label>
        <select id="trackSelect" aria-label="Track"></select>
      </div>

      <div class="row">
        <button id="saveSection" type="button">Save Section</button>
        <span id="abDisplay" class="small">A — • B —</span>
      </div>

      <div class="row">
        <button id="adaptivePlay" type="button">Adaptive Next</button>
        <label class="checkbox-label" for="loopToggle">
          <input type="checkbox" id="loopToggle" />
          Loop section
        </label>
      </div>

      <div class="row">
        <label for="speed">Speed</label>
        <input type="range" id="speed" min="0.5" max="1.5" step="0.01" value="1.0" />
        <span id="speedVal">1.00×</span>
      </div>

      <div class="row">
        <div class="mastery-pill">
          Focus mastery: <span id="masteryDisplay">—</span>
        </div>
      </div>

      <div id="waveformMount" class="waveform-wrap" aria-label="Waveform"></div>

      <audio id="audio" controls></audio>
    </section>

    <section class="card">
      <div class="section-header">
        <div>
          <h2>Saved Sections</h2>
          <p id="sectionSummary" class="small">Select a track to view saved sections for that track.</p>
        </div>
      </div>
      <div id="sectionList" class="section-list"></div>
    </section>
  </div>

  <script type="module" src="./src/app/bootstrap.js"></script>
</body>
</html>
</file>

</files>



<instruction>
<!--
  @role repository-instructions
  @owns repository-wide AI guidance, implementation-session rules, code-editing response-shape rules, requirement traceability rules, and process rules for keeping ownership metadata current
  @not-owns feature-planning process, planning-session behavior, or per-file implementation details that belong in planning-context.md or file headers
  @notes For comment-capable files, file headers are the authoritative source of per-file ownership. planning-context.md is the authoritative source for accepted product requirements and active feature deltas.
-->

# Repository Instructions

## How this repository is used with AI

The repository uses two distinct artifacts for AI-assisted work:

- `planning-context.md` for accepted product requirements and the currently agreed feature delta
- `repo-context.xml` for implementation-oriented repository context

In implementation sessions:

1. A generated `repo-context.xml` file is pasted into a chat session.
2. The user asks for a feature, bug fix, or refactor.
3. The AI uses the repository context together with `planning-context.md`, when present, to understand accepted requirements and the active feature delta.
4. Respond with complete file contents for every file that changes.
5. Do not return diff hunks unless explicitly requested.
6. Preserve the automated `repo-context.xml` workflow unless the request explicitly changes it.

## Source of truth

Use the following ownership split:

- `planning-context.md` is the source of truth for product requirements, including the accepted baseline and any currently agreed feature delta.
- `repomix-instruction.md` is the source of truth for repository-wide implementation rules, response shape, requirement traceability rules, and maintenance conventions.
- File headers are the source of truth for per-file ownership for comment-capable files.
- The current codebase remains the source of truth for actual implementation details.

Do not treat speculative ideas, aspirational roadmap items, or earlier conversational brainstorming as requirements unless they have been explicitly accepted into `planning-context.md`.

## Repo constraints

- This is a static browser app with no build step.
- `index.html` contains markup only.
- `styles.css` contains styling only.
- Prefer browser-native APIs over added dependencies.
- Preserve compatibility with the existing IndexedDB database when possible.
- File-level ownership rules live in file headers for comment-capable files and are the authoritative source for deciding where changes belong.
- Comment-capable files include source files, stylesheets, HTML files, workflow YAML files, markdown instruction files, and repository dotfiles such as `.gitignore`.
- `repomix.config.json` is a strict JSON file and should not receive comment headers; if it ever needs architectural notes, document them here.

## Use of planning context during implementation

When `planning-context.md` is present in the implementation context:

- treat accepted baseline requirements as stable unless the user explicitly asks to change them
- treat the current planning delta as the only active requirement change surface
- use requirement IDs, statuses, and allocations from `planning-context.md` when available
- preserve the distinction between unchanged baseline requirements and feature-specific changes
- do not silently reinterpret or renegotiate accepted requirements during implementation

If implementation reveals that an accepted requirement is infeasible, contradictory, or materially more complex than expected:

- say so explicitly
- identify the affected requirement
- explain the constraint or tradeoff
- ask to update planning rather than silently changing behavior

## Requirement definition and traceability

Product requirements are defined in `planning-context.md`.

Requirements must be:
- expressed as user-observable behavior or user-available capability
- implementation-agnostic
- stable across refactors
- allocated to product areas if helpful, but not split by code file

Requirements must not be defined as:
- file responsibilities
- modules, classes, functions, APIs, or data stores
- browser or storage implementation details
- internal architecture choices

File headers may include requirement traceability metadata, such as requirement IDs affected by that file.

Requirement traceability in file headers is for implementation mapping only. File headers do not define or redefine product requirements.

## File header convention

For comment-capable files, keep a short header at the top of the file using this shape:

- `@role`: what kind of module or file this is
- `@owns`: what this file is responsible for
- `@not-owns`: what should be changed elsewhere
- `@reqs`: optional requirement IDs this file materially contributes to
- `@notes`: optional short maintenance guidance

Keep headers concise and high-signal. Do not turn them into long prose blocks.

Use `@reqs` for requirement traceability only. Do not use it to redefine product requirements or to imply that requirements are owned by individual files.

## Keeping ownership metadata current

- When adding, removing, renaming, or moving a comment-capable file, update its header in the same change.
- When introducing a new architectural component such as a controller, store, service, renderer, adapter, or utility module, add or update the relevant file header immediately.
- When a file’s responsibility changes materially, update its `@owns` and `@not-owns` header entries in the same change.
- When a file materially begins or stops contributing to a traced requirement, update its `@reqs` metadata in the same change if that metadata is present in the repository.
- When a new file becomes part of the regular edit surface for future work, give it a header when the file format supports comments.
- Apply the same header discipline to comment-capable non-code files, including workflow files, markdown docs, and repository dotfiles.
- If a file format does not support comments, keep any necessary ownership guidance here in `repomix-instruction.md`.
- Treat this instruction file as the source of repository-wide rules, and treat file headers as the source of per-file ownership rules and optional requirement traceability.

## Change preferences

- Favor small, composable modules over a single large file.
- Avoid frameworks and build tooling unless explicitly requested.
- Keep the app easy to edit by copy/pasting full files from chat responses.
- Minimize comprehensive refactors, but if a change drives a reorganization propose the minimal sensible refactor.

## Expected response shape for code changes

- Group output by file path.
- Return the full contents of each changed file.
- Keep explanations brief unless the user asks for deeper design rationale.
</instruction>
