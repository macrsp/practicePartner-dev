This file is a merged representation of a subset of the codebase, containing specifically included files and files not matching ignore patterns, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

- Pay special attention to the Repository Instruction. These contain important context and guidelines specific to this project.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: **/*
- Files matching these patterns are excluded: dist, repo-context.xml
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.github/
  workflows/
    update-repo-context.yml
src/
  app.js
  constants.js
  db.js
  state.js
  ui.js
  utils.js
  waveform.js
.gitignore
index.html
repomix-instruction.md
repomix.config.json
styles.css
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="src/constants.js">
export const DB_NAME = "suzukiDB_v4";
export const DB_VERSION = 2;

export const STORES = {
  PROFILES: "profiles",
  SECTIONS: "sections",
  PLAYS: "plays",
};

export const DEFAULT_PROFILE_NAME = "Default";

export const SUPPORTED_AUDIO_EXTENSIONS = [
  ".mp3",
  ".wav",
  ".m4a",
  ".aac",
  ".ogg",
  ".flac",
];
</file>

<file path="src/db.js">
import { DB_NAME, DB_VERSION, STORES } from "./constants.js";

let dbPromise = null;

export function openDatabase() {
  if (dbPromise) {
    return dbPromise;
  }

  dbPromise = new Promise((resolve, reject) => {
    const request = indexedDB.open(DB_NAME, DB_VERSION);

    request.onupgradeneeded = (event) => {
      const database = event.target.result;
      const transaction = event.target.transaction;

      const profilesStore = database.objectStoreNames.contains(STORES.PROFILES)
        ? transaction.objectStore(STORES.PROFILES)
        : database.createObjectStore(STORES.PROFILES, {
            keyPath: "id",
            autoIncrement: true,
          });

      const sectionsStore = database.objectStoreNames.contains(STORES.SECTIONS)
        ? transaction.objectStore(STORES.SECTIONS)
        : database.createObjectStore(STORES.SECTIONS, {
            keyPath: "id",
            autoIncrement: true,
          });

      const playsStore = database.objectStoreNames.contains(STORES.PLAYS)
        ? transaction.objectStore(STORES.PLAYS)
        : database.createObjectStore(STORES.PLAYS, {
            keyPath: "id",
            autoIncrement: true,
          });

      if (!profilesStore.indexNames.contains("byName")) {
        profilesStore.createIndex("byName", "name", { unique: false });
      }

      if (!sectionsStore.indexNames.contains("byProfileId")) {
        sectionsStore.createIndex("byProfileId", "profileId", { unique: false });
      }

      if (!sectionsStore.indexNames.contains("byProfileAndTrack")) {
        sectionsStore.createIndex("byProfileAndTrack", ["profileId", "trackName"], {
          unique: false,
        });
      }

      if (!playsStore.indexNames.contains("bySectionId")) {
        playsStore.createIndex("bySectionId", "sectionId", { unique: false });
      }
    };

    request.onsuccess = () => resolve(request.result);
    request.onerror = () => reject(request.error);
  });

  return dbPromise;
}

function runRequest(storeName, mode, action) {
  return openDatabase().then(
    (database) =>
      new Promise((resolve, reject) => {
        const transaction = database.transaction(storeName, mode);
        const store = transaction.objectStore(storeName);
        let request;
        let result;

        try {
          request = action(store);
        } catch (error) {
          reject(error);
          return;
        }

        if (request) {
          request.onsuccess = () => {
            result = request.result;
          };
          request.onerror = () => reject(request.error);
        }

        transaction.oncomplete = () => resolve(result);
        transaction.onerror = () =>
          reject(transaction.error || request?.error || new Error("IndexedDB transaction failed."));
        transaction.onabort = () =>
          reject(transaction.error || request?.error || new Error("IndexedDB transaction aborted."));
      }),
  );
}

export function getAllProfiles() {
  return runRequest(STORES.PROFILES, "readonly", (store) => store.getAll());
}

export function addProfile(profile) {
  return runRequest(STORES.PROFILES, "readwrite", (store) => store.add(profile));
}

export function getSectionsByProfile(profileId) {
  return runRequest(STORES.SECTIONS, "readonly", (store) =>
    store.index("byProfileId").getAll(IDBKeyRange.only(profileId)),
  );
}

export function addSection(section) {
  return runRequest(STORES.SECTIONS, "readwrite", (store) => store.add(section));
}

export function updateSection(section) {
  return runRequest(STORES.SECTIONS, "readwrite", (store) => store.put(section));
}

export function deleteSection(sectionId) {
  return runRequest(STORES.SECTIONS, "readwrite", (store) => store.delete(sectionId));
}

export function addPlayLog(play) {
  return runRequest(STORES.PLAYS, "readwrite", (store) => store.add(play));
}
</file>

<file path="src/ui.js">
import { createSectionLabel, formatTime } from "./utils.js";

export const elements = {
  profileSelect: document.getElementById("profileSelect"),
  newProfile: document.getElementById("newProfile"),
  pickFolder: document.getElementById("pickFolder"),
  trackCount: document.getElementById("trackCount"),
  trackSelect: document.getElementById("trackSelect"),
  markA: document.getElementById("markA"),
  markB: document.getElementById("markB"),
  saveSection: document.getElementById("saveSection"),
  adaptivePlay: document.getElementById("adaptivePlay"),
  loopToggle: document.getElementById("loopToggle"),
  speed: document.getElementById("speed"),
  speedVal: document.getElementById("speedVal"),
  masteryDisplay: document.getElementById("masteryDisplay"),
  abDisplay: document.getElementById("abDisplay"),
  sectionSummary: document.getElementById("sectionSummary"),
  sectionList: document.getElementById("sectionList"),
  waveformMount: document.getElementById("waveformMount"),
  audio: document.getElementById("audio"),
};

export function renderProfiles(profiles, currentProfileId) {
  elements.profileSelect.innerHTML = "";

  if (!profiles.length) {
    const option = document.createElement("option");
    option.textContent = "No profiles";
    option.disabled = true;
    option.selected = true;
    elements.profileSelect.appendChild(option);
    elements.profileSelect.disabled = true;
    return;
  }

  profiles.forEach((profile) => {
    const option = document.createElement("option");
    option.value = String(profile.id);
    option.textContent = profile.name;
    elements.profileSelect.appendChild(option);
  });

  elements.profileSelect.disabled = false;
  elements.profileSelect.value = String(currentProfileId);
}

export function renderTracks(tracks, currentTrackName) {
  elements.trackSelect.innerHTML = "";

  if (!tracks.length) {
    const option = document.createElement("option");
    option.textContent = "Pick a folder to load tracks";
    option.disabled = true;
    option.selected = true;
    elements.trackSelect.appendChild(option);
    elements.trackSelect.disabled = true;
    return;
  }

  tracks.forEach((track, index) => {
    const option = document.createElement("option");
    option.value = String(index);
    option.textContent = track.name;
    if (track.name === currentTrackName) {
      option.selected = true;
    }
    elements.trackSelect.appendChild(option);
  });

  elements.trackSelect.disabled = false;
}

export function setTrackCount(text) {
  elements.trackCount.textContent = text;
}

export function setSelectionDisplay(start, end) {
  elements.abDisplay.textContent = `A ${formatTime(start)} • B ${formatTime(end)}`;
}

export function setSpeedDisplay(value) {
  elements.speedVal.textContent = `${Number(value).toFixed(2)}×`;
}

export function setMasteryDisplay(value) {
  elements.masteryDisplay.textContent = Number.isFinite(value) ? value.toFixed(2) : "—";
}

export function renderSections({
  sections,
  activeSectionId,
  currentTrackName,
  onFocus,
  onPlay,
  onDelete,
}) {
  elements.sectionList.innerHTML = "";

  const currentTrackText = currentTrackName ? ` Current track: ${currentTrackName}.` : "";
  elements.sectionSummary.textContent = sections.length
    ? `Showing ${sections.length} saved section${sections.length === 1 ? "" : "s"} in this profile.${currentTrackText}`
    : `No saved sections in this profile.${currentTrackText}`;

  if (!sections.length) {
    const empty = document.createElement("div");
    empty.className = "empty-state";
    empty.textContent = "Save a section after marking A and B, then it will appear here.";
    elements.sectionList.appendChild(empty);
    return;
  }

  sections.forEach((section) => {
    const row = document.createElement("div");
    row.className = "section-row";
    if (section.id === activeSectionId) {
      row.classList.add("is-active");
    }

    const main = document.createElement("div");
    main.className = "section-main";

    const title = document.createElement("div");
    title.className = "section-title";
    title.textContent = createSectionLabel(section);

    const meta = document.createElement("div");
    meta.className = "section-meta";
    meta.textContent =
      `${section.trackName} • plays ${section.playCount} • mastery ${section.mastery.toFixed(2)} • ` +
      `last played ${section.lastPlayed ? new Date(section.lastPlayed).toLocaleString() : "never"}`;

    main.appendChild(title);
    main.appendChild(meta);

    const actions = document.createElement("div");
    actions.className = "section-actions";

    const playButton = document.createElement("button");
    playButton.type = "button";
    playButton.textContent = "Play";
    playButton.addEventListener("click", (event) => {
      event.stopPropagation();
      onPlay(section.id);
    });

    const deleteButton = document.createElement("button");
    deleteButton.type = "button";
    deleteButton.className = "danger";
    deleteButton.textContent = "Delete";
    deleteButton.addEventListener("click", (event) => {
      event.stopPropagation();
      onDelete(section.id);
    });

    actions.appendChild(playButton);
    actions.appendChild(deleteButton);

    row.appendChild(main);
    row.appendChild(actions);
    row.addEventListener("click", () => onFocus(section.id));

    elements.sectionList.appendChild(row);
  });
}
</file>

<file path="src/utils.js">
import { SUPPORTED_AUDIO_EXTENSIONS } from "./constants.js";

const DAY_MS = 1000 * 60 * 60 * 24;

export function clamp(value, min, max) {
  return Math.min(max, Math.max(min, value));
}

export function isSupportedAudioFile(name) {
  const lower = name.toLowerCase();
  return SUPPORTED_AUDIO_EXTENSIONS.some((extension) => lower.endsWith(extension));
}

export function compareByName(a, b) {
  return a.name.localeCompare(b.name, undefined, {
    numeric: true,
    sensitivity: "base",
  });
}

export function formatTime(totalSeconds) {
  if (!Number.isFinite(totalSeconds)) {
    return "—";
  }

  const mins = Math.floor(totalSeconds / 60);
  const secs = totalSeconds - mins * 60;
  return `${mins}:${secs.toFixed(2).padStart(5, "0")}`;
}

export function createSectionLabel(section) {
  return `${formatTime(section.start)} → ${formatTime(section.end)}`;
}

export function normalizeSectionRecord(section) {
  return {
    ...section,
    playCount: section.playCount ?? 0,
    mastery: section.mastery ?? 0,
    lastPlayed: section.lastPlayed ?? 0,
    createdAt: section.createdAt ?? 0,
  };
}

export function calculateMastery(section, now = Date.now()) {
  const nextPlayCount = (section.playCount ?? 0) + 1;
  const repetitionScore = Math.min(1, nextPlayCount / 10);

  const daysSinceLastPlay = section.lastPlayed
    ? Math.max(0, (now - section.lastPlayed) / DAY_MS)
    : Infinity;

  const recencyScore = Number.isFinite(daysSinceLastPlay) ? 1 / (1 + daysSinceLastPlay) : 0;

  return Number(Math.min(1, 0.5 * repetitionScore + 0.5 * recencyScore).toFixed(2));
}

export function sortSections(a, b) {
  return (
    a.trackName.localeCompare(b.trackName, undefined, {
      numeric: true,
      sensitivity: "base",
    }) ||
    a.start - b.start ||
    a.end - b.end ||
    a.id - b.id
  );
}

export function summarizeTrackCount(count) {
  if (count === 0) {
    return "No audio files found in the selected folder.";
  }

  return `${count} track${count === 1 ? "" : "s"} loaded.`;
}

export function chooseAdaptiveSection(sections) {
  return (
    [...sections].sort(
      (a, b) =>
        a.mastery - b.mastery ||
        a.lastPlayed - b.lastPlayed ||
        a.playCount - b.playCount ||
        a.start - b.start,
    )[0] ?? null
  );
}
</file>

<file path=".gitignore">
dist/
.DS_Store
</file>

<file path="repomix.config.json">
{
  "$schema": "https://repomix.com/schemas/latest/schema.json",
  "output": {
    "filePath": "repo-context.xml",
    "style": "xml",
    "instructionFilePath": "repomix-instruction.md",
    "fileSummary": true,
    "directoryStructure": true,
    "files": true,
    "removeComments": false,
    "removeEmptyLines": false,
    "includeEmptyDirectories": false,
    "git": {
      "sortByChanges": true,
      "includeDiffs": false,
      "includeLogs": false
    }
  },
  "include": ["**/*"],
  "ignore": {
    "useGitignore": true,
    "useDefaultPatterns": true,
    "customPatterns": [
      "dist",
      "repo-context.xml"
    ]
  },
  "security": {
    "enableSecurityCheck": true
  },
  "tokenCount": {
    "encoding": "o200k_base"
  }
}
</file>

<file path="styles.css">
:root {
  --bg: #f4f6f8;
  --card: #ffffff;
  --card-alt: #f8fafc;
  --primary: #3b82f6;
  --primary-dark: #2563eb;
  --secondary: #e5e7eb;
  --danger: #ef4444;
  --danger-dark: #dc2626;
  --text: #1f2937;
  --muted: #6b7280;
  --border: #e5e7eb;
  --shadow: 0 6px 20px rgba(0, 0, 0, 0.05);
  --radius: 14px;
}

* {
  box-sizing: border-box;
}

body {
  margin: 0;
  padding: 24px;
  background: var(--bg);
  font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
  color: var(--text);
}

.container {
  max-width: 1040px;
  margin: 0 auto;
}

.page-header {
  margin-bottom: 20px;
}

h1 {
  font-size: 24px;
  margin: 0 0 6px;
  font-weight: 700;
}

h2 {
  font-size: 18px;
  margin: 0;
  font-weight: 650;
}

.card {
  background: var(--card);
  padding: 20px;
  border-radius: var(--radius);
  margin-bottom: 20px;
  box-shadow: var(--shadow);
}

.row {
  display: flex;
  gap: 12px;
  flex-wrap: wrap;
  align-items: center;
  margin-bottom: 12px;
}

.row:last-child {
  margin-bottom: 0;
}

label {
  font-size: 14px;
  color: var(--muted);
  font-weight: 600;
}

select,
input[type="range"] {
  padding: 9px 10px;
  border-radius: 10px;
  border: 1px solid var(--border);
  font-size: 14px;
  background: #fff;
}

select {
  min-width: 220px;
  max-width: 100%;
}

button {
  background: var(--primary);
  color: white;
  border: none;
  padding: 10px 16px;
  border-radius: 10px;
  cursor: pointer;
  font-weight: 600;
  transition: background 0.2s ease, transform 0.1s ease;
}

button:hover {
  background: var(--primary-dark);
}

button:active {
  transform: translateY(1px);
}

button.secondary {
  background: var(--secondary);
  color: var(--text);
}

button.secondary:hover {
  background: #d1d5db;
}

button.danger {
  background: var(--danger);
  color: #fff;
}

button.danger:hover {
  background: var(--danger-dark);
}

button:disabled,
select:disabled,
input:disabled {
  opacity: 0.6;
  cursor: not-allowed;
}

.checkbox-label {
  display: inline-flex;
  align-items: center;
  gap: 8px;
  user-select: none;
}

.waveform-wrap {
  width: 100%;
  margin-top: 12px;
  margin-bottom: 12px;
}

.waveform-canvas {
  width: 100%;
  display: block;
  border: 1px solid var(--border);
  border-radius: 12px;
  background: var(--card-alt);
}

audio {
  width: 100%;
  margin-top: 8px;
  border-radius: 12px;
}

.mastery-pill {
  background: #e0f2fe;
  color: #0369a1;
  padding: 6px 12px;
  border-radius: 999px;
  font-size: 13px;
  font-weight: 700;
}

.section-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 12px;
}

.section-list {
  display: grid;
  gap: 12px;
}

.section-row {
  display: flex;
  justify-content: space-between;
  gap: 12px;
  align-items: center;
  padding: 14px;
  border: 1px solid var(--border);
  border-radius: 12px;
  background: var(--card-alt);
  cursor: pointer;
}

.section-row:hover {
  border-color: #bfdbfe;
  background: #eff6ff;
}

.section-row.is-active {
  border-color: var(--primary);
  background: #dbeafe;
}

.section-main {
  min-width: 0;
}

.section-title {
  font-weight: 700;
  margin-bottom: 4px;
}

.section-meta {
  color: var(--muted);
  font-size: 13px;
  word-break: break-word;
}

.section-actions {
  display: flex;
  gap: 8px;
  flex-wrap: wrap;
}

.empty-state {
  border: 1px dashed var(--border);
  border-radius: 12px;
  padding: 18px;
  color: var(--muted);
  background: var(--card-alt);
}

.small {
  font-size: 13px;
  color: var(--muted);
}

@media (max-width: 720px) {
  body {
    padding: 16px;
  }

  .section-row {
    flex-direction: column;
    align-items: stretch;
  }

  .section-actions {
    justify-content: flex-start;
  }

  select {
    min-width: 0;
    width: 100%;
  }
}
</file>

<file path=".github/workflows/update-repo-context.yml">
name: Update Repo Context

on:
  push:
    branches-ignore:
      - main
    paths-ignore:
      - repo-context.xml
  workflow_dispatch:

permissions:
  contents: write

concurrency:
  group: update-repo-context-${{ github.ref }}
  cancel-in-progress: true

jobs:
  generate:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout current branch
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 22

      - name: Generate repo context
        run: npx --yes repomix@1.11.1 --config repomix.config.json

      - name: Upload repo context artifact
        uses: actions/upload-artifact@v4
        with:
          name: repo-context-${{ github.ref_name }}
          path: repo-context.xml

      - name: Commit updated repo context to branch
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git add repo-context.xml

          if git diff --cached --quiet; then
            echo "No repo context changes."
            exit 0
          fi

          git commit -m "chore: refresh repo context"
          git push origin HEAD:${GITHUB_REF_NAME}
</file>

<file path="src/app.js">
import { DEFAULT_PROFILE_NAME, SETTINGS_KEYS } from "./constants.js";
import {
  addPlayLog,
  addProfile,
  addSection,
  deleteSection,
  getAllProfiles,
  getSectionsByProfile,
  getSetting,
  openDatabase,
  setSetting,
  updateSection,
} from "./db.js";
import { state } from "./state.js";
import {
  elements,
  renderProfiles,
  renderSections,
  renderTracks,
  setMasteryDisplay,
  setSelectionDisplay,
  setSpeedDisplay,
  setTrackCount,
} from "./ui.js";
import {
  calculateMastery,
  chooseAdaptiveSection,
  compareByName,
  createSectionLabel,
  isSupportedAudioFile,
  normalizeSectionRecord,
  sortSections,
  summarizeTrackCount,
} from "./utils.js";
import { createWaveform } from "./waveform.js";

const audio = elements.audio;

const waveform = createWaveform({
  mountEl: elements.waveformMount,
  onSelectionChange: handleWaveformSelectionChange,
});

bindEvents();
bootstrap().catch(handleError);

async function bootstrap() {
  await openDatabase();
  await ensureDefaultProfile();

  renderTracks([], null);
  setTrackCount("No folder selected.");
  setSpeed(Number(elements.speed.value));

  await refreshProfiles();
  await restoreMusicFolder();
  refreshSelectionUi();
}

function bindEvents() {
  elements.profileSelect.addEventListener("change", async (event) => {
    state.currentProfileId = Number(event.target.value);
    state.focusedSectionId = null;
    state.currentPlayingSectionId = null;
    await refreshSections();
  });

  elements.newProfile.addEventListener("click", () => {
    void createProfile();
  });

  elements.pickFolder.addEventListener("click", () => {
    void pickMusicFolder();
  });

  elements.trackSelect.addEventListener("change", (event) => {
    const nextIndex = Number(event.target.value);
    void selectTrackByIndex(nextIndex);
  });

  elements.markA.addEventListener("click", () => {
    setSelectionMarker("start");
  });

  elements.markB.addEventListener("click", () => {
    setSelectionMarker("end");
  });

  elements.saveSection.addEventListener("click", () => {
    void saveSelectionAsSection();
  });

  elements.adaptivePlay.addEventListener("click", () => {
    void playAdaptiveSection();
  });

  elements.speed.addEventListener("input", (event) => {
    setSpeed(Number(event.target.value));
  });

  audio.addEventListener("timeupdate", () => {
    syncWaveformPlaybackPosition();
    void handleAudioBoundary();
  });
  audio.addEventListener("loadedmetadata", syncWaveformPlaybackPosition);
  audio.addEventListener("seeked", syncWaveformPlaybackPosition);
  audio.addEventListener("pause", syncWaveformPlaybackPosition);
  audio.addEventListener("ended", syncWaveformPlaybackPosition);

  window.addEventListener("unload", releaseCurrentTrackUrl);
}

async function ensureDefaultProfile() {
  const profiles = await getAllProfiles();

  if (!profiles.length) {
    await addProfile({ name: DEFAULT_PROFILE_NAME });
  }
}

async function refreshProfiles() {
  const profiles = await getAllProfiles();
  state.profiles = profiles;

  if (!profiles.length) {
    state.currentProfileId = null;
    renderProfiles([], null);
    await refreshSections();
    return;
  }

  if (!profiles.some((profile) => profile.id === state.currentProfileId)) {
    state.currentProfileId = profiles[0].id;
  }

  renderProfiles(profiles, state.currentProfileId);
  await refreshSections();
}

async function refreshSections() {
  if (!state.currentProfileId) {
    state.sections = [];
    renderSectionList();
    refreshMasteryUi();
    return;
  }

  const sections = await getSectionsByProfile(state.currentProfileId);
  state.sections = sections.map(normalizeSectionRecord).sort(sortSections);

  if (!state.sections.some((section) => section.id === state.focusedSectionId)) {
    state.focusedSectionId = null;
  }

  if (!state.sections.some((section) => section.id === state.currentPlayingSectionId)) {
    state.currentPlayingSectionId = null;
  }

  renderSectionList();
  refreshMasteryUi();
}

function renderSectionList() {
  renderSections({
    sections: state.sections,
    activeSectionId: state.currentPlayingSectionId ?? state.focusedSectionId,
    currentTrackName: state.currentTrack?.name ?? null,
    onFocus: (sectionId) => {
      void focusSection(sectionId);
    },
    onPlay: (sectionId) => {
      void playSectionById(sectionId);
    },
    onDelete: (sectionId) => {
      void removeSection(sectionId);
    },
  });
}

async function createProfile() {
  try {
    const name = window.prompt("Profile name?");
    const trimmed = name?.trim();

    if (!trimmed) {
      return;
    }

    const profileId = await addProfile({ name: trimmed });
    state.currentProfileId = profileId;
    await refreshProfiles();
  } catch (error) {
    handleError(error);
  }
}

async function restoreMusicFolder() {
  try {
    const [directoryHandle, folderName, lastTrackName] = await Promise.all([
      getSetting(SETTINGS_KEYS.MUSIC_FOLDER_HANDLE),
      getSetting(SETTINGS_KEYS.MUSIC_FOLDER_NAME),
      getSetting(SETTINGS_KEYS.LAST_TRACK_NAME),
    ]);

    if (!directoryHandle) {
      return;
    }

    state.currentFolderHandle = directoryHandle;
    state.currentFolderName = folderName || directoryHandle.name || null;

    const permissionState = await queryDirectoryPermission(directoryHandle);

    if (permissionState === "granted") {
      await loadTracksFromDirectory(directoryHandle, {
        preferredTrackName: lastTrackName ?? null,
      });
      return;
    }

    showRememberedFolderStatus();
  } catch (error) {
    console.warn("Unable to restore remembered music folder.", error);
    showRememberedFolderStatus();
  }
}

async function pickMusicFolder() {
  try {
    if (!window.showDirectoryPicker) {
      throw new Error("This browser does not support folder selection.");
    }

    if (state.currentFolderHandle && !state.tracks.length) {
      const permissionState = await queryDirectoryPermission(state.currentFolderHandle);

      if (permissionState !== "granted") {
        const requestedState = await requestDirectoryPermission(state.currentFolderHandle);

        if (requestedState === "granted") {
          const preferredTrackName = await getSetting(SETTINGS_KEYS.LAST_TRACK_NAME);
          await loadTracksFromDirectory(state.currentFolderHandle, {
            preferredTrackName: preferredTrackName ?? null,
          });
          return;
        }
      }
    }

    const previousTrackName =
      state.currentTrack?.name ?? (await getSetting(SETTINGS_KEYS.LAST_TRACK_NAME));
    const directoryHandle = await window.showDirectoryPicker();

    await rememberMusicFolder(directoryHandle);
    await loadTracksFromDirectory(directoryHandle, {
      preferredTrackName: previousTrackName ?? null,
    });
  } catch (error) {
    handleError(error);
  }
}

async function rememberMusicFolder(directoryHandle) {
  state.currentFolderHandle = directoryHandle;
  state.currentFolderName = directoryHandle.name ?? null;

  await Promise.all([
    setSetting(SETTINGS_KEYS.MUSIC_FOLDER_HANDLE, directoryHandle),
    setSetting(SETTINGS_KEYS.MUSIC_FOLDER_NAME, state.currentFolderName),
  ]);
}

async function loadTracksFromDirectory(directoryHandle, { preferredTrackName = null } = {}) {
  const nextTracks = [];

  for await (const [name, handle] of directoryHandle.entries()) {
    if (handle.kind !== "file" || !isSupportedAudioFile(name)) {
      continue;
    }

    const file = await handle.getFile();
    nextTracks.push({ name, file });
  }

  nextTracks.sort(compareByName);
  state.tracks = nextTracks;

  renderTracks(state.tracks, null);
  setTrackCount(summarizeTrackCount(nextTracks.length));

  if (!nextTracks.length) {
    clearCurrentTrack();
    return;
  }

  const nextIndex = preferredTrackName
    ? nextTracks.findIndex((track) => track.name === preferredTrackName)
    : 0;

  await selectTrackByIndex(nextIndex >= 0 ? nextIndex : 0);
}

async function queryDirectoryPermission(directoryHandle) {
  if (!directoryHandle?.queryPermission) {
    return "prompt";
  }

  return directoryHandle.queryPermission({ mode: "read" });
}

async function requestDirectoryPermission(directoryHandle) {
  if (!directoryHandle?.requestPermission) {
    return "granted";
  }

  return directoryHandle.requestPermission({ mode: "read" });
}

function showRememberedFolderStatus() {
  const folderName = state.currentFolderName
    ? `Remembered folder: ${state.currentFolderName}.`
    : "Folder remembered.";
  setTrackCount(`${folderName} Click Pick Music Folder to reconnect.`);
}

async function selectTrackByIndex(index, { preserveSelection = false } = {}) {
  const track = state.tracks[index];

  if (!track) {
    return;
  }

  audio.pause();
  state.currentPlayingSectionId = null;
  state.currentTrack = track;

  if (!preserveSelection) {
    state.selection = { start: null, end: null };
    state.focusedSectionId = null;
  }

  renderTracks(state.tracks, track.name);

  await Promise.all([loadAudioFile(track.file), waveform.loadFile(track.file)]);
  waveform.setPlaybackTime(audio.currentTime);
  await setSetting(SETTINGS_KEYS.LAST_TRACK_NAME, track.name);

  refreshSelectionUi();
  renderSectionList();
  refreshMasteryUi();
}

function clearCurrentTrack() {
  audio.pause();
  state.currentPlayingSectionId = null;
  state.currentTrack = null;
  state.selection = { start: null, end: null };
  state.focusedSectionId = null;

  releaseCurrentTrackUrl();
  audio.removeAttribute("src");
  audio.load();

  waveform.clear();
  renderTracks(state.tracks, null);
  refreshSelectionUi();
  renderSectionList();
  refreshMasteryUi();
}

async function loadAudioFile(file) {
  releaseCurrentTrackUrl();

  const objectUrl = URL.createObjectURL(file);
  state.currentTrackUrl = objectUrl;

  await new Promise((resolve, reject) => {
    const onLoadedMetadata = () => {
      cleanup();
      resolve();
    };

    const onError = () => {
      cleanup();
      reject(audio.error || new Error(`Unable to load audio file "${file.name}".`));
    };

    const cleanup = () => {
      audio.removeEventListener("loadedmetadata", onLoadedMetadata);
      audio.removeEventListener("error", onError);
    };

    audio.addEventListener("loadedmetadata", onLoadedMetadata);
    audio.addEventListener("error", onError);

    audio.src = objectUrl;
    audio.load();
  });

  audio.playbackRate = Number(elements.speed.value);
}

function releaseCurrentTrackUrl() {
  if (!state.currentTrackUrl) {
    return;
  }

  URL.revokeObjectURL(state.currentTrackUrl);
  state.currentTrackUrl = null;
}

function setSpeed(value) {
  audio.playbackRate = value;
  setSpeedDisplay(value);
}

function syncWaveformPlaybackPosition() {
  waveform.setPlaybackTime(Number.isFinite(audio.currentTime) ? audio.currentTime : null);
}

function refreshSelectionUi() {
  waveform.setSelection(state.selection);
  setSelectionDisplay(state.selection.start, state.selection.end);
}

function refreshMasteryUi() {
  const focusedSection =
    state.sections.find((section) => section.id === state.currentPlayingSectionId) ||
    state.sections.find((section) => section.id === state.focusedSectionId) ||
    null;

  setMasteryDisplay(focusedSection?.mastery ?? null);
}

function clearFocusedSectionForManualSelection() {
  if (state.currentPlayingSectionId || state.focusedSectionId == null) {
    return;
  }

  state.focusedSectionId = null;
  renderSectionList();
  refreshMasteryUi();
}

function handleWaveformSelectionChange(selection) {
  state.selection = selection;
  setSelectionDisplay(selection.start, selection.end);
  clearFocusedSectionForManualSelection();
}

function setSelectionMarker(key) {
  if (!state.currentTrack) {
    window.alert("Pick a track first.");
    return;
  }

  const currentTime = Number.isFinite(audio.currentTime) ? audio.currentTime : 0;
  state.selection = {
    ...state.selection,
    [key]: currentTime,
  };

  refreshSelectionUi();
  clearFocusedSectionForManualSelection();
}

async function saveSelectionAsSection() {
  try {
    if (!state.currentProfileId) {
      window.alert("Select a profile first.");
      return;
    }

    if (!state.currentTrack) {
      window.alert("Pick a track first.");
      return;
    }

    if (state.selection.start == null || state.selection.end == null) {
      window.alert("Mark both A and B before saving a section.");
      return;
    }

    const start = Math.min(state.selection.start, state.selection.end);
    const end = Math.max(state.selection.start, state.selection.end);

    if (Math.abs(end - start) < 0.05) {
      window.alert("The selected section is too short.");
      return;
    }

    const sectionId = await addSection({
      profileId: state.currentProfileId,
      trackName: state.currentTrack.name,
      start,
      end,
      playCount: 0,
      mastery: 0,
      lastPlayed: 0,
      createdAt: Date.now(),
    });

    state.focusedSectionId = sectionId;
    await refreshSections();
  } catch (error) {
    handleError(error);
  }
}

async function focusSection(sectionId) {
  try {
    const section = state.sections.find((item) => item.id === sectionId);

    if (!section) {
      return;
    }

    state.focusedSectionId = section.id;
    state.selection = {
      start: section.start,
      end: section.end,
    };

    const matchingTrackIndex = state.tracks.findIndex((track) => track.name === section.trackName);

    if (matchingTrackIndex !== -1 && state.currentTrack?.name !== section.trackName) {
      await selectTrackByIndex(matchingTrackIndex, { preserveSelection: true });
    }

    refreshSelectionUi();
    renderSectionList();
    refreshMasteryUi();
  } catch (error) {
    handleError(error);
  }
}

async function ensureTrackLoadedForSection(section) {
  const trackIndex = state.tracks.findIndex((track) => track.name === section.trackName);

  if (trackIndex === -1) {
    window.alert(
      `Track "${section.trackName}" is not available in the currently selected folder.`,
    );
    return false;
  }

  if (state.currentTrack?.name !== section.trackName) {
    await selectTrackByIndex(trackIndex, { preserveSelection: true });
  }

  return true;
}

async function playSectionById(sectionId) {
  try {
    const section = state.sections.find((item) => item.id === sectionId);

    if (!section) {
      return;
    }

    const ready = await ensureTrackLoadedForSection(section);

    if (!ready) {
      return;
    }

    state.currentPlayingSectionId = section.id;
    state.focusedSectionId = section.id;
    state.selection = {
      start: section.start,
      end: section.end,
    };

    refreshSelectionUi();
    renderSectionList();
    refreshMasteryUi();

    audio.currentTime = section.start;
    syncWaveformPlaybackPosition();
    await audio.play();
  } catch (error) {
    handleError(error);
  }
}

async function playAdaptiveSection() {
  try {
    if (!state.sections.length) {
      window.alert("There are no saved sections for this profile yet.");
      return;
    }

    const nextSection = chooseAdaptiveSection(state.sections);

    if (!nextSection) {
      return;
    }

    await playSectionById(nextSection.id);
  } catch (error) {
    handleError(error);
  }
}

async function handleAudioBoundary() {
  if (!state.currentPlayingSectionId) {
    return;
  }

  const activeSection = state.sections.find(
    (section) => section.id === state.currentPlayingSectionId,
  );

  if (!activeSection) {
    return;
  }

  if (audio.currentTime < activeSection.end) {
    return;
  }

  if (elements.loopToggle.checked) {
    audio.currentTime = activeSection.start;
    syncWaveformPlaybackPosition();
    return;
  }

  audio.pause();
  audio.currentTime = activeSection.end;
  syncWaveformPlaybackPosition();

  const completedSectionId = state.currentPlayingSectionId;
  state.currentPlayingSectionId = null;
  renderSectionList();

  await finalizeSectionPlay(completedSectionId);
}

async function finalizeSectionPlay(sectionId) {
  const section = state.sections.find((item) => item.id === sectionId);

  if (!section) {
    return;
  }

  const now = Date.now();
  const updatedSection = {
    ...section,
    playCount: section.playCount + 1,
    lastPlayed: now,
    mastery: calculateMastery(section, now),
  };

  await updateSection(updatedSection);
  await addPlayLog({
    sectionId,
    timestamp: now,
    speed: audio.playbackRate,
  });

  state.focusedSectionId = sectionId;
  await refreshSections();
}

async function removeSection(sectionId) {
  try {
    const section = state.sections.find((item) => item.id === sectionId);

    if (!section) {
      return;
    }

    const confirmed = window.confirm(`Delete section ${createSectionLabel(section)}?`);

    if (!confirmed) {
      return;
    }

    if (state.currentPlayingSectionId === sectionId) {
      audio.pause();
      state.currentPlayingSectionId = null;
    }

    if (state.focusedSectionId === sectionId) {
      state.focusedSectionId = null;
    }

    await deleteSection(sectionId);
    await refreshSections();
  } catch (error) {
    handleError(error);
  }
}

function handleError(error) {
  if (!error || error.name === "AbortError") {
    return;
  }

  console.error(error);
  window.alert(error.message || "Something went wrong.");
}
</file>

<file path="src/state.js">
export const state = {
  profiles: [],
  currentProfileId: null,
  currentFolderHandle: null,
  currentFolderName: null,
  tracks: [],
  currentTrack: null,
  currentTrackUrl: null,
  sections: [],
  selection: {
    start: null,
    end: null,
  },
  focusedSectionId: null,
  currentPlayingSectionId: null,
};
</file>

<file path="src/waveform.js">
import { clamp } from "./utils.js";

const COLORS = {
  background: "#f8fafc",
  waveform: "#cbd5e1",
  playedFill: "rgba(249, 115, 22, 0.12)",
  playheadLine: "#f97316",
  selectionFill: "rgba(59, 130, 246, 0.20)",
  selectionLine: "#2563eb",
  text: "#6b7280",
};

export function createWaveform({ mountEl, onSelectionChange }) {
  const canvas = document.createElement("canvas");
  canvas.className = "waveform-canvas";
  canvas.height = 140;
  canvas.style.touchAction = "none";
  mountEl.appendChild(canvas);

  const ctx = canvas.getContext("2d");

  let audioBuffer = null;
  let selection = { start: null, end: null };
  let playbackTime = null;
  let dragging = false;

  function resize() {
    canvas.width = Math.max(320, Math.floor(mountEl.clientWidth || 320));
    canvas.height = 140;
    draw();
  }

  window.addEventListener("resize", resize);

  canvas.addEventListener("pointerdown", handlePointerDown);
  canvas.addEventListener("pointermove", handlePointerMove);
  canvas.addEventListener("pointerup", handlePointerUp);
  canvas.addEventListener("pointerleave", handlePointerUp);

  resize();

  function getDuration() {
    return audioBuffer?.duration ?? 0;
  }

  function getNormalizedSelection() {
    const duration = getDuration();
    return {
      start: Number.isFinite(selection.start) ? clamp(selection.start, 0, duration) : null,
      end: Number.isFinite(selection.end) ? clamp(selection.end, 0, duration) : null,
    };
  }

  function getNormalizedPlaybackTime() {
    const duration = getDuration();
    return Number.isFinite(playbackTime) ? clamp(playbackTime, 0, duration) : null;
  }

  function drawPlaceholder(message) {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = COLORS.background;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = COLORS.text;
    ctx.font = "14px system-ui, sans-serif";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText(message, canvas.width / 2, canvas.height / 2);
  }

  function xToTime(x) {
    const duration = getDuration();
    if (!duration) {
      return 0;
    }

    return (clamp(x, 0, canvas.width) / canvas.width) * duration;
  }

  function timeToX(time) {
    const duration = getDuration();
    if (!duration) {
      return 0;
    }

    return (clamp(time, 0, duration) / duration) * canvas.width;
  }

  function draw() {
    if (!audioBuffer) {
      drawPlaceholder("Pick a track to see the waveform.");
      return;
    }

    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = COLORS.background;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    const channelData = audioBuffer.getChannelData(0);
    const step = Math.max(1, Math.ceil(channelData.length / canvas.width));
    const amplitude = canvas.height / 2;

    ctx.fillStyle = COLORS.waveform;

    for (let x = 0; x < canvas.width; x += 1) {
      let min = 1;
      let max = -1;
      const offset = x * step;

      for (let i = 0; i < step; i += 1) {
        const sample = channelData[offset + i];
        if (sample === undefined) {
          break;
        }
        if (sample < min) {
          min = sample;
        }
        if (sample > max) {
          max = sample;
        }
      }

      ctx.fillRect(x, (1 + min) * amplitude, 1, Math.max(1, (max - min) * amplitude));
    }

    drawPlaybackRegion();
    drawSelection();
    drawPlayhead();
  }

  function drawMarker(time, label) {
    const x = timeToX(time);

    ctx.setLineDash([6, 4]);
    ctx.strokeStyle = COLORS.selectionLine;
    ctx.beginPath();
    ctx.moveTo(x, 0);
    ctx.lineTo(x, canvas.height);
    ctx.stroke();
    ctx.setLineDash([]);

    ctx.fillStyle = COLORS.selectionLine;
    ctx.font = "12px system-ui, sans-serif";
    ctx.textAlign = "left";
    ctx.textBaseline = "top";
    ctx.fillText(label, Math.min(canvas.width - 20, x + 4), 6);
  }

  function drawPlaybackRegion() {
    const currentTime = getNormalizedPlaybackTime();

    if (currentTime == null) {
      return;
    }

    const x = timeToX(currentTime);

    if (x <= 0) {
      return;
    }

    ctx.fillStyle = COLORS.playedFill;
    ctx.fillRect(0, 0, x, canvas.height);
  }

  function drawPlayhead() {
    const currentTime = getNormalizedPlaybackTime();

    if (currentTime == null) {
      return;
    }

    const x = timeToX(currentTime);

    ctx.strokeStyle = COLORS.playheadLine;
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(x, 0);
    ctx.lineTo(x, canvas.height);
    ctx.stroke();
    ctx.lineWidth = 1;
  }

  function drawSelection() {
    const current = getNormalizedSelection();

    if (current.start == null && current.end == null) {
      return;
    }

    if (current.start != null && current.end != null) {
      const startX = timeToX(current.start);
      const endX = timeToX(current.end);

      ctx.fillStyle = COLORS.selectionFill;
      ctx.fillRect(Math.min(startX, endX), 0, Math.abs(endX - startX), canvas.height);
    }

    if (current.start != null) {
      drawMarker(current.start, "A");
    }

    if (current.end != null) {
      drawMarker(current.end, "B");
    }
  }

  function setSelection(nextSelection, { notify = false } = {}) {
    selection = {
      start: Number.isFinite(nextSelection?.start) ? nextSelection.start : null,
      end: Number.isFinite(nextSelection?.end) ? nextSelection.end : null,
    };

    draw();

    if (notify) {
      onSelectionChange?.({ ...getNormalizedSelection() });
    }
  }

  function setPlaybackTime(nextPlaybackTime) {
    playbackTime = Number.isFinite(nextPlaybackTime) ? nextPlaybackTime : null;
    draw();
  }

  async function loadFile(file) {
    drawPlaceholder("Loading waveform…");

    const arrayBuffer = await file.arrayBuffer();
    const AudioContextCtor = window.AudioContext || window.webkitAudioContext;

    if (!AudioContextCtor) {
      audioBuffer = null;
      drawPlaceholder("Waveform preview is unavailable in this browser.");
      return;
    }

    const audioContext = new AudioContextCtor();

    try {
      audioBuffer = await audioContext.decodeAudioData(arrayBuffer.slice(0));
      playbackTime = 0;
    } finally {
      if (audioContext.close) {
        await audioContext.close();
      }
    }

    draw();
  }

  function clear() {
    audioBuffer = null;
    selection = { start: null, end: null };
    playbackTime = null;
    draw();
  }

  function handlePointerDown(event) {
    if (!audioBuffer) {
      return;
    }

    canvas.setPointerCapture(event.pointerId);
    dragging = true;

    const rect = canvas.getBoundingClientRect();
    const time = xToTime(event.clientX - rect.left);

    setSelection({ start: time, end: time }, { notify: true });
  }

  function handlePointerMove(event) {
    if (!dragging || !audioBuffer) {
      return;
    }

    const rect = canvas.getBoundingClientRect();
    const time = xToTime(event.clientX - rect.left);

    setSelection({ start: selection.start, end: time }, { notify: true });
  }

  function handlePointerUp(event) {
    if (dragging && canvas.hasPointerCapture(event.pointerId)) {
      canvas.releasePointerCapture(event.pointerId);
    }

    dragging = false;
  }

  return {
    clear,
    loadFile,
    setPlaybackTime,
    setSelection,
    getSelection: () => ({ ...getNormalizedSelection() }),
  };
}
</file>

<file path="repomix-instruction.md">
# Repository Instructions

## How this repository is used with AI

1. A generated `repo-context.xml` file is pasted into a chat session.
2. The user asks for a feature, bug fix, or refactor.
3. Respond with complete file contents for every file that changes.
4. Do not return diff hunks unless explicitly requested.
5. Preserve the automated `repo-context.xml` workflow unless the request explicitly changes it.

## Repo constraints

- This is a static browser app with no build step.
- `index.html` contains markup only.
- `styles.css` contains styling only.
- `src/app.js` orchestrates behavior and event wiring.
- `src/db.js` owns IndexedDB access.
- `src/ui.js` owns DOM rendering and section list UI.
- `src/waveform.js` owns waveform rendering and drag selection.
- `repo-context.xml` is generated by GitHub Actions on non-`main` branch pushes and committed back to that same branch.
- `repo-context.xml` should not be edited manually.

## Change preferences

- Favor small, composable modules over a single large file.
- Preserve compatibility with the existing IndexedDB database when possible.
- Avoid frameworks and build tooling unless explicitly requested.
- Keep the app easy to edit by copy/pasting full files from chat responses.
- Prefer browser-native APIs over added dependencies.
- Minimize comprehenive refactors, but if a change drives a reorganization propose the minimal sensible refactor. 

## Expected response shape for code changes

- Group output by file path.
- Return the full contents of each changed file.
- Keep explanations brief unless the user asks for deeper design rationale.
</file>

<file path="index.html">
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Suzuki Practice Partner</title>
  <link rel="stylesheet" href="./styles.css" />
</head>
<body>
  <div class="container">
    <header class="page-header">
      <h1>Suzuki Practice Partner</h1>
      <p class="small">
        Waveform-driven section practice with profiles, repeat tracking, and adaptive playback.
      </p>
    </header>

    <section class="card">
      <div class="row">
        <label for="profileSelect">Profile</label>
        <select id="profileSelect" aria-label="Profile"></select>
        <button id="newProfile" type="button" class="secondary">New Profile</button>
      </div>
    </section>

    <section class="card">
      <div class="row">
        <button id="pickFolder" type="button">Pick Music Folder</button>
        <span id="trackCount" class="small">No folder selected.</span>
      </div>

      <div class="row">
        <label for="trackSelect">Track</label>
        <select id="trackSelect" aria-label="Track"></select>
      </div>

      <div class="row">
        <button id="markA" type="button" class="secondary">Mark A</button>
        <button id="markB" type="button" class="secondary">Mark B</button>
        <button id="saveSection" type="button">Save Section</button>
        <span id="abDisplay" class="small">A — • B —</span>
      </div>

      <div class="row">
        <button id="adaptivePlay" type="button">Adaptive Next</button>
        <label class="checkbox-label" for="loopToggle">
          <input type="checkbox" id="loopToggle" />
          Loop section
        </label>
      </div>

      <div class="row">
        <label for="speed">Speed</label>
        <input type="range" id="speed" min="0.5" max="1.5" step="0.01" value="1.0" />
        <span id="speedVal">1.00×</span>
      </div>

      <div class="row">
        <div class="mastery-pill">
          Focus mastery: <span id="masteryDisplay">—</span>
        </div>
      </div>

      <div id="waveformMount" class="waveform-wrap" aria-label="Waveform"></div>

      <audio id="audio" controls></audio>
    </section>

    <section class="card">
      <div class="section-header">
        <div>
          <h2>Saved Sections</h2>
          <p id="sectionSummary" class="small">No saved sections yet.</p>
        </div>
      </div>
      <div id="sectionList" class="section-list"></div>
    </section>
  </div>

  <script type="module" src="./src/app.js"></script>
</body>
</html>
</file>

</files>



<instruction>
# Repository Instructions

## How this repository is used with AI

1. A generated `repo-context.xml` file is pasted into a chat session.
2. The user asks for a feature, bug fix, or refactor.
3. Respond with complete file contents for every file that changes.
4. Do not return diff hunks unless explicitly requested.
5. Preserve the automated `repo-context.xml` workflow unless the request explicitly changes it.

## Repo constraints

- This is a static browser app with no build step.
- `index.html` contains markup only.
- `styles.css` contains styling only.
- `src/app.js` orchestrates behavior and event wiring.
- `src/db.js` owns IndexedDB access.
- `src/ui.js` owns DOM rendering and section list UI.
- `src/waveform.js` owns waveform rendering and drag selection.
- `repo-context.xml` is generated by GitHub Actions on non-`main` branch pushes and committed back to that same branch.
- `repo-context.xml` should not be edited manually.

## Change preferences

- Favor small, composable modules over a single large file.
- Preserve compatibility with the existing IndexedDB database when possible.
- Avoid frameworks and build tooling unless explicitly requested.
- Keep the app easy to edit by copy/pasting full files from chat responses.
- Prefer browser-native APIs over added dependencies.
- Minimize comprehenive refactors, but if a change drives a reorganization propose the minimal sensible refactor. 

## Expected response shape for code changes

- Group output by file path.
- Return the full contents of each changed file.
- Keep explanations brief unless the user asks for deeper design rationale.

</instruction>
